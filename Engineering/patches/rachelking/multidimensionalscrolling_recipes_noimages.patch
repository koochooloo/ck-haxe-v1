Index: Engineering/src/game/ui/MultidimensionalScrollingMenu.hx
===================================================================
--- Engineering/src/game/ui/MultidimensionalScrollingMenu.hx	(revision 832)
+++ Engineering/src/game/ui/MultidimensionalScrollingMenu.hx	(working copy)
@@ -42,10 +42,7 @@
 	private var m_visibleRows:Int;
 	private var m_rowSpacing:Float;
 	
-	private var m_colPos:Null<Float>;
-	private var m_rowPos:Null<Float>;
 	
-	
 	/**
 	 * @param	centerRef - top left object in a scrolling gred
 	 * @param	bottomRef - object directly below center ref 
@@ -63,6 +60,7 @@
 		// - Start & End pos
 		// - List of scrolling items
 		// ---------------------------------------------------
+		m_paistRef = centerRef;
 		addMultiRef( centerRef, bottomRef, rightRef );
 		
 		// ---------------------------------------------------
@@ -102,7 +100,7 @@
 		if ( rightRef != null )
 		{
 			m_colSpacing = rightRef.x - centerRef.x; // Includes item size + padding
-			m_visibleCols = Math.floor( m_scrollArea.width / m_colSpacing );
+			m_visibleCols = Math.ceil( m_scrollArea.width / m_colSpacing );
 		}
 		
 		// ----------------------------------------------------
@@ -115,13 +113,30 @@
 			m_visibleRows = Math.floor( m_scrollArea.height / m_rowSpacing );
 		}
 		
+		// Set visible items for bounds checking
+		m_visibleItems = m_visibleRows * m_visibleCols; 
+		
 		// ----------------------------------------------------
 		// Populate a set of items based on above dimensions.
 		// Items are filled taking the scroll orientation into account, 
 		// 		such that the last row/col of items in the list are at the scroll end.
 		// ----------------------------------------------------
+		populateScrollingItems();
 		
-		m_visibleItems = m_visibleRows * m_visibleCols; // used for bounds checking
+		// Hide ref
+		centerRef.visible = false;
+		bottomRef.visible = false;
+		rightRef.visible = false;
+	}
+	
+	// ===================================
+	// Object positioning helper functions
+	// ===================================
+	
+	private override function populateScrollingItems()
+	{
+		var startX:Float = m_paistRef.x;
+		var startY:Float = m_paistRef.y;
 		
 		var numRows:Int = m_visibleRows;
 		var numCols:Int = m_visibleCols;
@@ -133,26 +148,27 @@
 		{	
 			case Orientation.HORIZONTAL:
 			{
-				numCols+= 1; // Since we are adding new columns when scrolling, place an extra set out of view
-				var initXPos:Float = centerRef.x;
-				var initYPos:Float = centerRef.y;
+				numCols += 0; // Since we are adding new rows when scrolling, place an extra set out of view
+				var initXPos:Float = m_paistRef.x; 
+				var initYPos:Float = m_paistRef.y;
 				rowOffset = initYPos;
 				colOffset = initXPos;
+				
 				for ( col in 0...numCols )
 				{
 					rowOffset = initYPos;
-					
-					for ( row in 0...numRows)
+
+					for ( row in 0...numRows )
 					{
-						var item:VirtualScrollingItem = new VirtualScrollingItem( centerRef, count );
+						var item:VirtualScrollingItem = new VirtualScrollingItem( m_paistRef, count );
 						item.addMask( m_scrollArea );
 						item.setCoordinates( colOffset, rowOffset );
 						m_scrollingItems.push( item );
-						
+
 						rowOffset += m_rowSpacing;
 						count++; // Temp - debugging
 					}
-
+					
 					colOffset += m_colSpacing;
 				}
 			}
@@ -159,17 +175,17 @@
 			case Orientation.VERTICAL:
 			{
 				numRows += 1; // Since we are adding new rows when scrolling, place an extra set out of view
-				var initXPos:Float = centerRef.x;
-				var initYPos:Float = centerRef.y;
+				var initXPos:Float = m_paistRef.x;
+				var initYPos:Float = m_paistRef.y;
 				rowOffset = initYPos;
 				colOffset = initXPos;
 				for ( row in 0...numRows)
-				{	
+				{
 					colOffset = initXPos;
 					
 					for ( col in 0...numCols )
 					{
-						var item:VirtualScrollingItem = new VirtualScrollingItem( centerRef, count );
+						var item:VirtualScrollingItem = new VirtualScrollingItem( m_paistRef, count );
 						item.addMask( m_scrollArea );
 						item.setCoordinates( colOffset, rowOffset );
 						m_scrollingItems.push( item );
@@ -183,15 +199,9 @@
 			}
 		}
 		
-		centerRef.visible = false;
-		bottomRef.visible = false;
-		rightRef.visible = false;
+		m_paistRef.x = startX;
+		m_paistRef.y = startY;
 	}
-	
-	// ===================================
-	// Object positioning helper functions
-	// ===================================
-	
 	/**
 	 * Checks if list & repopulates a scrolling item at the top or bottom as needed
 	 */
@@ -203,41 +213,37 @@
 			return;
 		}
 		
-		switch( m_orientation )
+		switch( dir )
 		{
-			case HORIZONTAL: // todo
-			case VERTICAL:
+			case FORWARD:	
 			{
-				switch( dir )
+				if ( scrolledOneItemForward() )
 				{
-					case FORWARD:	
-					{
-						if ( scrolledOneItemForward() )
-						{
-							repositionSetAtStart();
-						}
-					}
-					case BACKWARD:  
-					{
-						if ( scrolledOneItemBackward() )
-						{
-							repositionSetAtEnd();
-						}
-
-					}
+					var repositioned:Int = repositionSetAtStart();
+					m_userPos -= repositioned;
+					trace( "Repositioned forward " + m_userPos );
 				}
 			}
+			case BACKWARD:  
+			{
+				if ( scrolledOneItemBackward() )
+				{
+					var repositioned:Int = repositionSetAtEnd();
+					m_userPos += repositioned;
+					trace( "Repositioned backward " + m_userPos );
+				}
+			}
 		}
 	}
 	
 	/**
-	 * Take the last items of the list and place it at the top
-	 * Returns reference to them for data updates.
+	 * Take the last items of the list and place it just above the first items of the list.
+	 * Returns true if you hit a new set.
 	 * */
-	private function repositionSetAtStart():Void
+	private function repositionSetAtStart():Int
 	{
-		var firstRow:Array< VirtualScrollingItem > = new Array();
-		var lastRow:Array< VirtualScrollingItem > = new Array();
+		var firstSet:Array< VirtualScrollingItem > = new Array();
+		var lastSet:Array< VirtualScrollingItem > = new Array();
 		switch ( m_orientation )
 		{
 			case Orientation.VERTICAL:
@@ -245,7 +251,7 @@
 				// Get the first row of the list 
 				for ( item in m_scrollingItems )
 				{
-					firstRow.push( item );
+					firstSet.push( item );
 				}
 				
 				// Get the the items in the last row
@@ -258,7 +264,7 @@
 					var item:VirtualScrollingItem = m_scrollingItems[ idx ];
 					if ( item.posY() == lastRowPos )
 					{
-						lastRow.push( m_scrollingItems[ idx ] );
+						lastSet.push( m_scrollingItems[ idx ] );
 					}
 					
 					idx--;
@@ -267,39 +273,38 @@
 				
 				// Fill in items from right -> left (opposite RepositionAtEnd) 
 				// First row items will be rightmost
-				var rowPos:Float = 0;
-				var colPos:Float = 0;
-				var firstRowItem:VirtualScrollingItem = firstRow[ 0 ];
-				var firstRowColPos:Float = firstRowItem.posX();
+				var firstItem:VirtualScrollingItem = firstSet[ 0 ];
+				var rowPos:Float = firstItem.posY();
+				var colPos:Float = firstItem.posX();
 				
 				// Figure out repositioning start point based on the item placement in the top row
-				var topRowFull:Bool = (firstRowColPos - m_colSpacing) < m_scrollArea.x;
+				var topRowFull:Bool = (firstItem.posX() - m_colSpacing) < m_scrollArea.x;
 				if ( topRowFull )
 				{
 					// If the top row is full, place at far right one row up
-					rowPos = firstRowItem.posY() - m_rowSpacing;
-					colPos = firstRowItem.posX() + ( m_colSpacing * (m_visibleCols - 1) );
+					rowPos = firstItem.posY() - m_rowSpacing;
+					colPos = firstItem.posX() + ( m_colSpacing * (m_visibleCols - 1) );
 				}
 				else
 				{
 					// Otherwise, we fill in one from the right side
-					colPos = firstRowItem.posX() - m_colSpacing;
-					rowPos = firstRowItem.posY();
+					colPos = firstItem.posX() - m_colSpacing;
 				}
 
-				for ( i in 0...lastRow.length )
+				var placedItems:Int = 0;
+				for ( i in 0...lastSet.length )
 				{
+					var dataIdx:Int = m_userPos - (m_visibleCols) - i;
 					// Do not complete the row if we are at the end of the dataset
-					var dataIdx:Int = m_userPos - m_visibleCols;
-					if ( (dataIdx) < 0 )
+					// Early return if out of data bounds
+					if ( (dataIdx) <= 0 )
 					{
-						m_userPos--; // Decrease user pos to hit end of bounds
 						break;
 					}
 					
 					// Get item we are repositioning + item whose position we are referencing
-					var firstRowItem:VirtualScrollingItem = firstRow[ i ];
-					var lastRowItem:VirtualScrollingItem = lastRow[ i ];
+					var firstRowItem:VirtualScrollingItem = firstSet[ i ];
+					var lastRowItem:VirtualScrollingItem = lastSet[ i ];
 
 					// Change item screen position
 					lastRowItem.setCoordinates( colPos, rowPos);
@@ -310,25 +315,107 @@
 					m_scrollingItems.insert( 0, lastRowItem ); // Add to beginning
 					
 					// Update item data
-					m_userPos--;
 					lastRowItem.updateData( m_dataset[dataIdx] );
+					placedItems++;
 				}
+				
+				return placedItems;
 			}
 			case HORIZONTAL:
 			{
-				// todo
+				// Get the first row of the list 
+				var count:Int = 0;
+				while ( count < m_visibleCols )
+				{
+					firstSet.push( m_scrollingItems[ count ] );
+					count++;
+				}
+				
+				// Get the the items in the last column
+				var idx:Int = m_scrollingItems.length - 1;
+				var count:Int = 0;
+				while ( count < m_visibleCols )
+				{
+					var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
+					var lastRowPos:Float = lastItem.posX();
+					var item:VirtualScrollingItem = m_scrollingItems[ idx ];
+					if ( item.posX() == lastRowPos )
+					{
+						lastSet.push( m_scrollingItems[ idx ] );
+					}
+					
+					idx--;
+					count++;
+				}
+				
+				// Fill in items from bottom -> top (opposite RepositionAtEnd) 
+				// First row items will be rightmost
+				var rowPos:Float = 0;
+				var colPos:Float = 0;
+				var firstColItem:VirtualScrollingItem = firstSet[ 0 ];
+				var firstColPos:Float = firstColItem.posY();
+				
+				// Figure out repositioning start point based on the item placement in the top row
+				var firstColFull:Bool = (firstColPos - m_colSpacing) < m_scrollArea.y;
+				if ( firstColFull )
+				{
+					// If the leftmost column is full, place at bottom of a new col one to the bottom/left of it
+					colPos = firstColItem.posX() - m_colSpacing;
+					rowPos = firstColItem.posY() + (m_rowSpacing * (m_visibleRows - 1) );
+				}
+				else
+				{
+					// Otherwise, we fill in one on top
+					colPos = firstColItem.posX();
+					rowPos = firstColItem.posY() - m_rowSpacing;
+				}
+
+				var placedItems:Int = 0;
+				for ( i in 0...lastSet.length )
+				{
+					// Do not complete the row if we are at the end of the dataset
+					var dataIdx:Int = m_userPos - m_visibleRows + i;
+					if ( (dataIdx) < 0 )
+					{
+						break;
+					}
+					
+					// Get item we are repositioning + item whose position we are referencing
+					var firstColItem:VirtualScrollingItem = firstSet[ i ];
+					var lastColItem:VirtualScrollingItem = lastSet[ i ];
+
+					// Change item screen position
+					lastColItem.setCoordinates( colPos, rowPos);
+					
+					// Update item's position in the array
+					m_scrollingItems.remove( lastColItem ); // Remove from end (first instance of item)
+					m_scrollingItems.insert( 0, lastColItem ); // Add to beginning
+					
+					rowPos -= m_rowSpacing;
+					
+					// Update item data
+					lastColItem.updateData( m_dataset[dataIdx] );
+					placedItems++;
+				}
+				
+				return placedItems;
 			}
+		
 		}
+	
+		
+		return 0;
+
 	}
 	
 	/**
-	 * Take the first row  of the list and place it at the bottom
-	 * Returns reference to them for data updates.
+	 * Take the first row or column  of the list and place it just beyond the last row/col of the list.
+	 * Returns true if you hit a new set.
 	 * */
-	private function repositionSetAtEnd():Void
+	private function repositionSetAtEnd():Int
 	{
-		var firstRow:Array< VirtualScrollingItem > = new Array();
-		var lastRow:Array< VirtualScrollingItem > = new Array();
+		var firstSet:Array< VirtualScrollingItem > = new Array(); // Row or column
+		var lastSet:Array< VirtualScrollingItem > = new Array(); // Row or column
 		switch ( m_orientation )
 		{
 			case VERTICAL:
@@ -336,7 +423,7 @@
 				// Get the first row of the list 
 				for ( item in m_scrollingItems )
 				{
-					firstRow.push( item );
+					firstSet.push( item );
 				}
 				
 				// Get the the items in the last row
@@ -344,27 +431,26 @@
 				var count:Int = 0;
 				while ( count < m_visibleCols )
 				{
-					lastRow.push( m_scrollingItems[ idx ] );
+					lastSet.push( m_scrollingItems[ idx ] );
 					idx--;
 					count++;
 				}
 				
 				// Pull items from left -> right (opposite RepositionAtStart)
+				var placedItems = 0;
 				for ( i in 0...m_visibleCols )
 				{
 					// Get item data index 
-					var dataIdx:Int = m_userPos + (m_visibleCols * 2);
-					
+					var dataIdx:Int = m_userPos + (m_visibleCols * 2) + i;
 					// Do not complete the row if we are at the end of the dataset
 					if ( (dataIdx) >= m_dataset.length )
-					{
-						m_userPos++; // Increase user pos to hit end of bounds
+					{ 
 						break;
 					}
 					
 					// Change item screen position
-					var firstRowItem:VirtualScrollingItem = firstRow[ i ];
-					var lastRowItem:VirtualScrollingItem = lastRow[ lastRow.length - 1 - i ];
+					var firstRowItem:VirtualScrollingItem = firstSet[ i ];
+					var lastRowItem:VirtualScrollingItem = lastSet[ lastSet.length - 1 - i ];
 					firstRowItem.setCoordinates( lastRowItem.posX(), lastRowItem.posY() + m_rowSpacing );
 					
 					// Update item's position in the array
@@ -372,15 +458,66 @@
 					m_scrollingItems.push( firstRowItem ); // Add to end
 					
 					// Update item data
-					m_userPos++;
 					firstRowItem.updateData( m_dataset[dataIdx] );
+					placedItems++;
 				}
+				
+				return placedItems;
 			}
 			case HORIZONTAL:
 			{
-				// todo
-			}
+				// Get the first column of the list 
+				var count:Int = 0;
+				while ( count < m_visibleRows )
+				{
+					firstSet.push( m_scrollingItems[ count ] );
+					count++;
+				}
+				
+				// Get the the items in the last column
+				var idx:Int = m_scrollingItems.length - 1;
+				var count:Int = 0;
+				while ( count < m_visibleRows )
+				{
+					lastSet.push( m_scrollingItems[ idx ] );
+					idx--;
+					count++;
+				}
+				
+				// Pull items from top -> bottom (opposite RepositionAtStart)
+				var placedItems:Int = 0;
+				for ( i in 0...m_visibleRows )
+				{
+					// Get item data index 
+					var dataIdx:Int = m_userPos + (m_visibleRows * m_visibleCols) + i;
+					trace( "data index: " + dataIdx );
+					
+					// Do not complete the row if we are at the end of the dataset
+					if ( (dataIdx) >= m_dataset.length )
+					{
+						break;
+					}
+					
+					// Change item screen position
+					var firstColItem:VirtualScrollingItem = firstSet[ i ];
+					var lastColItem:VirtualScrollingItem = lastSet[ lastSet.length - 1 - i ];
+					firstColItem.setCoordinates( lastColItem.posX() + m_colSpacing, lastColItem.posY() );
+
+					// Update item's position in the array
+					m_scrollingItems.remove( firstColItem ); // Remove from beginning (first instance of item)
+					m_scrollingItems.push( firstColItem ); // Add to end
+					
+					// Update item data
+					firstColItem.updateData( m_dataset[dataIdx] );
+					placedItems++;
+				}
+				
+				return placedItems;
+			 }
+		
 		}
+	
+		return 0;
 	}
 	
 	/**
@@ -387,9 +524,34 @@
 	 * Returns true if the bottom left corner of the first item in the list is below (left of) the start pos.
 	 * Assumes top-left corner object anchoring.
 	 */
-	private override function scrolledOneItemForward():Bool
+	private override function scrolledOneItemBackward():Bool
 	{
-		var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
-		return ( lastItem.pos(m_orientation) >= m_lowerScrollLimit);
+		var firstItem:VirtualScrollingItem = m_scrollingItems[ 0 ];
+		return ( (firstItem.pos(m_orientation) + m_itemSize)  <= m_upperScrollLimit );
 	}
+	
+	private override function atUpperScrollLimit():Bool
+	{
+		var offset:Int = switch ( m_orientation ) // Data array index offset, based on number of rows/columns
+		{
+			case Orientation.VERTICAL:   m_visibleCols;
+			case Orientation.HORIZONTAL: 0;//m_visibleRows;
+		}
+		var firstDisplayedIdx:Int = m_userPos;
+		var firstDataIdx:Int = offset;
+		return scrolledOneItemForward() && firstDisplayedIdx <= firstDataIdx;
+	}
+	
+	private override function atLowerScrollLimit():Bool
+	{
+		var offset:Int = switch ( m_orientation ) // Data array index offset, based on number of rows/columns
+		{
+			case Orientation.VERTICAL:   m_visibleCols;
+			case Orientation.HORIZONTAL: m_visibleRows;
+		}
+		
+		var lastDisplayedIdx:Int = offset + m_userPos;
+		var lastSetIdx:Int = m_dataset.length - offset;
+		return scrolledOneItemBackward() && ( lastDisplayedIdx >= lastSetIdx );
+	}
 }
\ No newline at end of file
Index: Engineering/src/game/ui/states/RecipesMenu.hx
===================================================================
--- Engineering/src/game/ui/states/RecipesMenu.hx	(revision 829)
+++ Engineering/src/game/ui/states/RecipesMenu.hx	(working copy)
@@ -19,6 +19,8 @@
 import com.firstplayable.hxlib.display.OPSprite;
 import com.firstplayable.hxlib.loader.ResMan;
 import com.firstplayable.hxlib.state.IGameState.GameStateParams;
+import format.pdf.Filter;
+import format.swf.Data.FontLayoutData;
 import game.Country;
 import game.Recipe;
 import game.controllers.FlowController;
@@ -25,7 +27,8 @@
 import game.def.GameState;
 import game.def.RecipeTypes;
 import game.net.NetAssets;
-import game.ui.ScrollingManager;
+import game.ui.MultidimensionalScrollingMenu;
+import game.ui.VirtualScrollingMenu.Orientation;
 import game.ui.SpeckMenu;
 import openfl.display.Bitmap;
 import openfl.display.DisplayObject;
@@ -55,47 +58,35 @@
 
 class RecipesMenu extends SpeckMenu
 {
-	// ------ Static tunable vars:
-	// TODO - callback to pull from paist bounding box
-	private static inline var SCROLLWIDTH:Float = 900;
-	private static inline var SCROLLHEIGHT:Float = 600;
-	private static inline var DISPLAYNUM:Int = 6;
-	private static inline var CATEGORYNUM:Int = 7;
-	
 	// ------ Member vars:
-	private var m_scrollMenu:ScrollingManager;
+	private var m_scrollMenu:MultidimensionalScrollingMenu;
 	private var m_categories:Array< RecipeTypes >;
 	private var m_paistGroups:Array< RecipeGroup >;
 	private var m_categoryUp:Bitmap;
 	private var m_categoryDown:Bitmap;
 	private var m_searchTerms:TextField;
-	
-	//  Indices of left and rightmost rendered objects 
-	private var m_renderRight:Int; 
-	private var m_renderLeft:Int;
-	
-	//	Keeps track of persistent up/down toggle for category buttons.
+	private static var DEFAULT_SEARCH:String;
+
+	//	toggledStates: Keeps track of persistent up/down toggle for category buttons.
 	//		Down state = toggled = true. 
 	//		Up state = untoggled = false. 
-	private var m_toggledStates:Map< String, Bool >;
-	
-	private var DEMORECIPES:Array< String > = [ "Coconut Rice", "Filipino Noodles", "Green Garam Sprouts Salad", "Peachy Panzanella Salad", "Persian Meat Balls", "Potato Pancake", "Spring Rolls", "Tuna Sandwiches", "Tomato and Olive Penne", "Whole Wheat Crepes"];    
-	private static var DEFAULT_SEARCH:String;
-	
+	private var m_toggledStates:Map< RecipeTypes, Bool >;
+
 	public function new( ?p:GameStateParams) 
 	{
 		super( "RecipesMenu" );
 		
+		// ----------------------------------------------------
 		// Initialize members
+		// ----------------------------------------------------
 		m_toggledStates = new Map();
 		m_categories = new Array();
-		m_paistGroups = getPaistReference();
-		m_renderLeft = 0;
-		m_renderRight = DISPLAYNUM;
 		m_categoryUp = ResMan.instance.getImage( "2d/Buttons/btn_recipeCategory_up" );
 		m_categoryDown = ResMan.instance.getImage( "2d/Buttons/btn_recipeCategory_down" );
 		
-		// If this menu has been given GameStateParams, we came here from a Country menu
+		// ----------------------------------------------------
+		// Set country title, if necessary
+		// ----------------------------------------------------
 		if ( FlowController.currentPath == FlowPath.CONSUMER_COUNTRY )
 		{
 			// Set menu title
@@ -103,20 +94,25 @@
 			title.text = FlowController.data.selectedCountry.name;
 		}
 		
-		// Initialize states for all category buttons.
-		// 		There are seven categories, ID starting from 0. 
-		//		All button start out untoggled (up, false)
-		for (n in 0...CATEGORYNUM) 
+		// ----------------------------------------------------
+		// Initialize states for all category buttons
+		// ----------------------------------------------------
+		// 	There are seven categories, ID starting from 0. 
+		//	All button start out untoggled (up, false)
+		var enums:Array< RecipeTypes > = Type.allEnums(RecipeTypes);
+		for (n in 0...enums.length) 
 		{
-			var name:String = getButtonById( n ).name;
-			m_toggledStates.set( name, false ); 
+			var categoryButton:GraphicButton = getButtonById( n );			
+			categoryButton.onHit = onCategoryHit;
+			
+			var category:RecipeTypes = Type.allEnums(RecipeTypes)[ n ];
+			trace( category );
+			m_toggledStates.set( category, false );
 		}
 		
-		// Create Scroll menu
-		var scrollBounds:DisplayObjectContainer = cast getChildByName( "scroll_border" );
-		m_scrollMenu = new ScrollingManager( scrollBounds.x, scrollBounds.y, SCROLLWIDTH, SCROLLHEIGHT, this, "horizontal", DISPLAYNUM );
-		
+		// ----------------------------------------------------
 		// Initialize search bar 
+		// ----------------------------------------------------
 		m_searchTerms = cast getChildByName( "lbl_rSearch" );
 		if ( DEFAULT_SEARCH == null ) 		
 			DEFAULT_SEARCH = m_searchTerms.text;
@@ -126,12 +122,18 @@
 		m_searchTerms.addEventListener( FocusEvent.FOCUS_IN, onFocusIn );
 		m_searchTerms.addEventListener( FocusEvent.FOCUS_OUT, onFocusOut );
 		
-		// Initialize recipe buttons & add them to the scroll menu.
-		drawRecipes();
+		// ----------------------------------------------------
+		// Create & initialize scroll menu
+		// ----------------------------------------------------
+		var scrollBounds:OPSprite = cast getChildByName( "spr_scrollBounds" );
+		var centerRef:DisplayObjectContainer = cast getChildByName( "group_recipe0" );
+		var rightRef:DisplayObjectContainer = cast getChildByName( "group_recipe1" );
+		var bottomRef:DisplayObjectContainer = cast getChildByName( "group_recipe3" );
+		m_scrollMenu = new MultidimensionalScrollingMenu( scrollBounds, HORIZONTAL, centerRef, bottomRef, rightRef );
 		
-		// Initialize scroll menu
+		addRecipeData();
+		this.addChild( m_scrollMenu );
 		m_scrollMenu.init();
-		this.addChild( m_scrollMenu );
 	}
 	
 	override public function onButtonHit( ?caller:GraphicButton ):Void 
@@ -141,69 +143,88 @@
 		// Button naming convention: btn_(type)(number)
 		var name:String = caller.name;
 		var type:String = name.substring(4, name.length - 1);
-		var number:String = name.charAt(name.length - 1);
 		
-		// Category buttons filter the recipes displayed.
-		// When toggled, refresh the recipes that are being displayed. 
-		if (type == "category")
+		WebAudio.instance.play( "SFX/recipe_click" );
+		
+		// On this menu, if it's not a category button, it's a recipe button. 
+		// Set the selected recipe and go to the next state in the flow
+		var recipe:Recipe = SpeckGlobals.dataManager.allRecipes.get( name.substring(4, name.length) );
+		var country:Country = SpeckGlobals.dataManager.allCountries.get( recipe.country );
+		
+		FlowController.data.selectedRecipe = recipe;
+		FlowController.data.selectedCountry = country;
+		FlowController.goToNext();
+	}
+	
+	private function onCategoryHit( ?caller:GraphicButton ):Void
+	{
+		WebAudio.instance.play( "SFX/button_click" );	
+
+		var number:Int = Std.parseInt( caller.name.charAt(name.length) );
+		var category:RecipeTypes = Type.allEnums(RecipeTypes)[ number ];
+		var isDown:Bool = m_toggledStates.get( category );
+				
+		if ( isDown )
 		{
-			var category:RecipeTypes = null;
-			var isDown:Bool = m_toggledStates.get( name );
+			// Switch button to up (untoggled, false)
+			m_toggledStates.set( category, false );
+			caller.upState = m_categoryUp;
+			caller.downState = m_categoryUp;
+			caller.overState = m_categoryUp;
 			
-			// Pattern match vs cateogry enum
-			switch( number )
-			{
-				case "0": 	category = RecipeTypes.VEGETARIAN;
-				case "1": 	category = RecipeTypes.DAIRYFREE;
-				case "2": 	category = RecipeTypes.GLUTENFREE;
-				case "3": 	category = RecipeTypes.APPETIZERS;
-				case "4": 	category = RecipeTypes.BREAKFAST;
-				case "5": 	category = RecipeTypes.MAINCOURSE;
-				case "6": 	category = RecipeTypes.DESSERT;
-			}
-			if ( isDown )
-			{
-				// Switch button to up (untoggled, false)
-				m_toggledStates.set( name, false );
-				caller.upState = m_categoryUp;
-				caller.downState = m_categoryUp;
-				caller.overState = m_categoryUp;
-				
-				// Remove filter & redraw recipes 
-				m_categories.remove( category );
-				drawRecipes();
-			}
-			else
-			{
-				// Switch button to down (toggled, true)
-				m_toggledStates.set( name, true );
-				caller.upState = m_categoryDown;
-				caller.downState = m_categoryDown;
-				caller.overState = m_categoryDown;
-				
-				// Add filter and redraw recipes
-				m_categories.push( category );
-				drawRecipes();
-			}
+			// Remove filter & redraw recipes 
+			m_categories.remove( category );
+			drawRecipes();
 		}
 		else
 		{
-			WebAudio.instance.play( "SFX/recipe_click" );
+			// Switch button to down (toggled, true)
+			m_toggledStates.set( category, true );
+			caller.upState = m_categoryDown;
+			caller.downState = m_categoryDown;
+			caller.overState = m_categoryDown;
 			
-			// On this menu, if it's not a category button, it's a recipe button. 
-			// Set the selected recipe and go to the next state in the flow
-			var recipe:Recipe = SpeckGlobals.dataManager.allRecipes.get( name.substring(4, name.length) );
-			var country:Country = SpeckGlobals.dataManager.allCountries.get( recipe.country );
-			
-			FlowController.data.selectedRecipe = recipe;
-			FlowController.data.selectedCountry = country;
-			FlowController.goToNext();
-			
-			return;
+			// Add filter and redraw recipes
+			m_categories.push( category );
+			drawRecipes();
 		}
+	}
+	
+	private function addRecipeData()
+	{
+		// Get search filter
+		var filter:String = m_searchTerms.text;
 		
-		WebAudio.instance.play( "SFX/button_click" );	
+		var count:Int = 0;
+		for ( recipe in SpeckGlobals.dataManager.allRecipes )
+		{
+			if ( isDisplayable( recipe, filter ) )
+			{
+				// ----------------------------------------------------
+				// Get recipe text
+				// ----------------------------------------------------
+				var label:String = recipe.name;
 
+				// ----------------------------------------------------
+				// Get button base
+				// ----------------------------------------------------
+				var baseButtonImg:Bitmap = ResMan.instance.getImage( "2d/Buttons/btn_recipe_up" );
+				var baseButton:GraphicButton = new GraphicButton( baseButtonImg, baseButtonImg, baseButtonImg, baseButtonImg, null, onButtonHit );
+
+				// ----------------------------------------------------
+				// Setup initial recipe image - TODO - DATABASE 
+				// ----------------------------------------------------
+				// Get image
+				var centerRef:DisplayObjectContainer = cast getChildByName( "group_recipe0" );
+				var recipeImgRef:OPSprite = cast centerRef.getChildByName( "image0" );
+				
+				count++;
+				
+				var recipeImg:Bitmap = getRecipeImage( recipe, recipeImgRef, count );
+				m_scrollMenu.addData( recipeImg, baseButtonImg, null, label );
+
+			}
+		}
 	}
 	
 	// Flips the boolean for a given category button
@@ -214,199 +235,43 @@
 		return m_toggledStates.get( buttonName );
 	}
 	
-	private function getPaistReference():Array< RecipeGroup >
+	// Creates a masterlist of recipe buttons and adds them to the scroll menu
+	private function drawRecipes():Void
 	{
-		// Get paist reference
-		var paistGroups:Array< RecipeGroup > = new Array();
+		// Clear scroll menu
+		m_scrollMenu.reset();
 		
-		for ( n in 0...DISPLAYNUM )
-		{
-			var panel:DisplayObjectContainer = cast getChildByName( "group_recipe" + n );
-			var button:GraphicButton = cast panel.getChildByName( "btn_recipe" + n );
-			var label:TextField = cast panel.getChildByName( "lbl_Name" + n);
-			var image:OPSprite = cast panel.getChildByName( "image" + n);
-			paistGroups.push( { panel: panel, button: button, label: label, image: image } );
-			
-			panel.visible = false; // Hide layout items
-		}
+		// Re-add recipe data with new filter/s
+		addRecipeData();
 		
-		return paistGroups;
+		// Start up scroll menu again
+		m_scrollMenu.reInit();
 	}
 	
-	// Creates a masterlist of recipe buttons and adds them to the scroll menu
-	private function drawRecipes():Void
+	/**
+	 * Checks recipe name against the search filter, recipe ingredients against the allergens list,
+	 * 		and recipe meal types against the category filters.
+	 */
+	private function isDisplayable( recipe:Recipe, filter:String ):Bool
 	{
-		// Get search filter
-		var filter:String = m_searchTerms.text;
-		
-		// Clear scroll list
-		m_scrollMenu.clear();
-		
-		// Get button column spacing for offset placement
-		var colSpacing:Float = m_paistGroups[ 1 ].panel.x - m_paistGroups[ 0 ].panel.x; // X difference between two adj items
-		
-		// Loop through recipes and add them to the scroll manager 
-		var pos:Int = 0; // Loop through positions in the array of paist references
-		var offset:Float = 0; // Increment every time we've looped through the whole pos list.
-		
-		for ( recipe in SpeckGlobals.dataManager.allRecipes )
+		var isCountryRecipe:Bool = true;
+		if ( FlowController.currentPath == FlowPath.CONSUMER_COUNTRY )
 		{
-			// If we have a selected country, only show recipes from that country
-			var isCountryRecipe:Bool = true;
-			if ( FlowController.currentPath == FlowPath.CONSUMER_COUNTRY )
+			if ( FlowController.data.selectedCountry.name != recipe.country )
 			{
-				if ( FlowController.data.selectedCountry.name != recipe.country )
-				{
-					isCountryRecipe = false;
-				}
+				isCountryRecipe = false;
 			}
-
-			// Verify that the recipe being displayed has the given search filter
-			var hasFilter:Bool = ( filter == DEFAULT_SEARCH ) || ( recipe.name.toLowerCase().indexOf( filter.toLowerCase() ) >= 0 ); 
+		}
 			
-			// Viable tests if it is in the selected categories and is not a marked allergen
-			if ( isCountryRecipe && hasFilter && recipe.isViable( m_categories ) ) 
-			{
-				var DEMONAME:String = StringTools.replace( recipe.name, " ", "_" );
-				
-				var ref:RecipeGroup = m_paistGroups[ pos ];
-
-				var panel:DisplayObjectContainer = new DisplayObjectContainer();
-				panel.x = ref.panel.x + offset;
-				panel.y = ref.panel.y;
-				
-				var img:Bitmap = ResMan.instance.getImage( "2d/UI/recipeSelect" );
-				var button:GraphicButton = new GraphicButton( img, img, img, img, null, onButtonHit );
-				button.x = ref.button.x;
-				button.y = ref.button.y;
-				button.name = "btn_" + recipe.name;
-				panel.addChild( button );
-				
-				var label:TextField = new TextField();
-				label.text = recipe.name;
-				label.x = ref.label.x;
-				label.y = ref.label.y;
-				label.width = 200;
-				label.height = 40;
-				label.setTextFormat( ref.label.getTextFormat() );
-				label.multiline = true;
-				label.wordWrap = true;
-				panel.addChild( label );
-				
-				//======================================================
-				// Setup initial recipe image
-				//======================================================
-				var img2:Bitmap;
-				if (Tunables.USE_DATABASE_RESOURCES)
-				{
-					img2 = ResMan.instance.getImageUnsafe( "2d/UI/recipesLarge/loading" );
-					//trigger load later.
-				}
-				else
-				{
-					img2 = ResMan.instance.getImageUnsafe( "2d/UI/recipesLarge/recipe_" + DEMONAME + "_01" );
-					if ( img2 == null ) // TEMP WHILE LACKING DATABASE HOOKUP - use placeholder if no recipe image
-					{
-						img2 = ResMan.instance.getImage( "2d/UI/recipesLarge/placeholder" );
-					}
-				}
-				
-				var recipeImageBtn:GraphicButton = new GraphicButton( img2, img2, img2, img2, null, onButtonHit ); 
-				
-				// Image is sized to keep the same dimensions, but scale up until it hits the dimensions.
-				var imageScaleW:Float = ref.image.width / recipeImageBtn.width;
-				var imageScaleH:Float = ref.image.height / recipeImageBtn.height;
-				
-				if ( recipeImageBtn.width >= recipeImageBtn.height )
-				{
-					recipeImageBtn.scaleX = imageScaleW;
-					recipeImageBtn.scaleY = imageScaleW;
-				}
-				else if ( recipeImageBtn.height > recipeImageBtn.width )
-				{
-					recipeImageBtn.scaleX = imageScaleH;
-					recipeImageBtn.scaleY = imageScaleH;
-				}
-				
-				var xOffsetRecipe:Float = ref.image.x - ref.button.x;
-				var yOffsetRecipe:Float = ref.image.y - ref.button.y;
-				recipeImageBtn.x = xOffsetRecipe;
-				recipeImageBtn.y = yOffsetRecipe;
-				button.addChild( recipeImageBtn );
-				
-				var recipeImageButtonName:String = "img_" + recipe.name;
-				recipeImageBtn.name = recipeImageButtonName;
-				
-				//======================================
-				// Trigger loading of actual recipe image
-				// TODO: consider doing this only when the recipe becomes visible?
-				//======================================
-				if (Tunables.USE_DATABASE_RESOURCES)
-				{
-					if (recipe.image != null)
-					{
-						NetAssets.instance.getImage(recipe.image, function(downloadedImg:Bitmap){
-							if (downloadedImg != null)
-							{
-								button.removeChild(recipeImageBtn);
-								
-								var newRecipeImageBtn:GraphicButton = new GraphicButton( downloadedImg, downloadedImg, downloadedImg, downloadedImg, null, onButtonHit ); 
-								// Image is sized to keep the same dimension ratios, but scale up until it hits the dimensions of the container
-								var imageScaleW:Float = ref.image.width / newRecipeImageBtn.width;
-								var imageScaleH:Float = ref.image.height / newRecipeImageBtn.height;
-								
-								if ( newRecipeImageBtn.width >= newRecipeImageBtn.height )
-								{
-									newRecipeImageBtn.scaleX = imageScaleW;
-									newRecipeImageBtn.scaleY = imageScaleW;
-									
-									yOffsetRecipe += (newRecipeImageBtn.width - newRecipeImageBtn.height) / 2;
-								}
-								else if ( newRecipeImageBtn.height > newRecipeImageBtn.width )
-								{
-									newRecipeImageBtn.scaleX = imageScaleH;
-									newRecipeImageBtn.scaleY = imageScaleH;
-									
-									xOffsetRecipe += (newRecipeImageBtn.height - newRecipeImageBtn.width) / 2;
-								}
-								
-								newRecipeImageBtn.x = xOffsetRecipe;
-								newRecipeImageBtn.y = yOffsetRecipe;
-								
-								button.addChild( newRecipeImageBtn );
-								newRecipeImageBtn.name = recipeImageButtonName;
-							}
-						});
-					}
-				}
-				
-				this.addChild( panel );
-
-				// Add to scroll menu
-				m_scrollMenu.addItem( panel, button );
-				
-				// Increment/loop position
-				if ( pos == 5)
-				{
-					pos = 0;
-					offset += colSpacing * 3 ; // New set of buttons uses the same ref but is built (offset) pixels to the right
-											   // 	TODO - replace this with virtual lists
-				}
-				else
-				{
-					pos++;
-				}
-			}
-		}
-		
-		showMask();
+		var hasFilter:Bool = ( filter == DEFAULT_SEARCH ) || ( recipe.name.toLowerCase().indexOf( filter.toLowerCase() ) >= 0 ); 
+		return ( isCountryRecipe && hasFilter && recipe.isViable( m_categories ) );
 	}
 	
-	private function showMask():Void
-	{
-		m_scrollMenu.reparent();
-	}
 	
+	// ===================================
+	// Search/text management functions
+	// ===================================
+	
 	private function onTextUpdate( e:Event ):Void 
 	{
 		drawRecipes();
@@ -428,4 +293,41 @@
 			m_searchTerms.text = DEFAULT_SEARCH;
 		}
 	}
+	
+	
+	private function getRecipeImage( recipe:Recipe, ref:OPSprite, count:Int ):Bitmap
+	{		
+		//======================================================
+		// Setup initial recipe image
+		//======================================================
+		var img:Bitmap;
+		if (Tunables.USE_DATABASE_RESOURCES && count < 10)
+		{
+			img = ResMan.instance.getImageUnsafe( "2d/UI/recipesLarge/loading" );
+			//trigger load later.
+		}
+		else
+		{
+			img = ResMan.instance.getImage( "2d/UI/recipesLarge/placeholder" );
+		}
+
+		//======================================
+		// Trigger loading of actual recipe image
+		// TODO: consider doing this only when the recipe becomes visible?
+		//======================================
+		if (Tunables.USE_DATABASE_RESOURCES)
+		{
+			if (recipe.image != null)
+			{
+				NetAssets.instance.getImage(recipe.image, function(downloadedImg:Bitmap){
+					if (downloadedImg != null)
+					{
+						img = downloadedImg;
+					}
+				});
+			}
+		}
+		
+		return img;
+	}
 }
\ No newline at end of file
Index: Engineering/src/game/ui/VirtualScrollingItem.hx
===================================================================
--- Engineering/src/game/ui/VirtualScrollingItem.hx	(revision 832)
+++ Engineering/src/game/ui/VirtualScrollingItem.hx	(working copy)
@@ -35,7 +35,7 @@
 class VirtualScrollingItem extends DisplayObjectContainer
 {
 	private var refGroup:DisplayObjectContainer;
-	private var group:DisplayObjectContainer;
+	public var group:DisplayObjectContainer;
 	public var  debugName:Int;
 	
 	// Display objects (update these for individual-list functionality. 
@@ -93,6 +93,7 @@
 				createSpriteFromRef( cast (child, OPSprite) );
 			}
 		}
+
 	}
 	
 	/**
@@ -122,7 +123,7 @@
 	{
 		switch ( data.imgSrc )
 		{
-			case Some( src ): setImage( src );
+			case Some( bitmap ): setImage( bitmap );
 			case None: //
 		}
 		switch ( data.label )
@@ -140,6 +141,10 @@
 			case Some( bitmap ): setButton( bitmap, m_buttons[1] );
 			case None: //
 		}
+		
+		
+		m_baseScaleX = group.scaleX;
+		m_baseScaleY = group.scaleY;
 	}
 	
 	/**
@@ -147,10 +152,12 @@
 	 * Assumes one image in display list
 	 * Naiive - TODO database integration
 	 */
-	private function setImage( src:String ):Void
+	private function setImage( bitmap:Bitmap ):Void
 	{
-		var bitmap:Bitmap = ResMan.instance.getImage( src );
 		m_image.changeImage( bitmap );
+		
+		m_image.width = 140;
+		m_image.height = 140;
 	}
 	
 	/**
@@ -267,21 +274,21 @@
 	 */
 	public function handleButtonOverState( posX:Float, posY:Float ):Void
 	{
+		
 		for ( button in m_buttons )
 		{
-			var scaledUp:Bool = ( button.scaleX > m_baseScaleX && button.scaleY > m_baseScaleY );
-			var scaledDown:Bool = ( button.scaleX <= m_baseScaleX && button.scaleY <= m_baseScaleY );
+			var scaledUp:Bool = ( group.scaleX > m_baseScaleX && group.scaleY > m_baseScaleY );
+			var scaledDown:Bool = ( group.scaleX <= m_baseScaleX && group.scaleY <= m_baseScaleY );
 			
-			// If scaled up and mouse isn't over the button, scale down again
 			if ( !pointInObject( posX, posY, button ) && scaledUp ) 
 			{
-				button.scaleX /= BUTTON_OVERSTATE_SCALE;
-				button.scaleY /= BUTTON_OVERSTATE_SCALE;	
+				group.scaleX /= BUTTON_OVERSTATE_SCALE;
+				group.scaleY /= BUTTON_OVERSTATE_SCALE;	
 			}
 			else if ( pointInObject( posX, posY, button ) && scaledDown )
 			{
-				button.scaleX *= BUTTON_OVERSTATE_SCALE;
-				button.scaleY *= BUTTON_OVERSTATE_SCALE;
+				group.scaleX *= BUTTON_OVERSTATE_SCALE;
+				group.scaleY *= BUTTON_OVERSTATE_SCALE;
 			}
 		}
 	}
@@ -339,11 +346,7 @@
 		newBtn.cursor = ref.cursor;
 		newBtn.rotation = ref.rotation;
 		newBtn.name = ref.name;
-		
-		m_baseScaleX = ref.scaleX;
-		m_baseScaleY = ref.scaleY;
 
-
 		m_buttons.push( newBtn );
 		group.addChild( newBtn );
 	
@@ -380,7 +383,9 @@
 	 */
 	private function createSpriteFromRef( ref:OPSprite ):OPSprite
 	{
-		var newSprite:OPSprite = new OPSprite( ref.getBitmap(), ref.getBoundsData() );
+		var newSprite:OPSprite = new OPSprite();
+		newSprite.bitmapData = ref.getBitmapData();
+
 		newSprite.width = ref.width;
 		newSprite.height = ref.height;
 		newSprite.x = ref.x;
@@ -388,10 +393,10 @@
 		newSprite.visible = ref.visible;
 		newSprite.alpha = ref.alpha;
 		newSprite.rotation = ref.rotation;
-		newSprite.name = ref.name; 
-		
+		newSprite.name = ref.name + debugName;
+		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
 		m_image = newSprite;
-		group.addChild( newSprite );
+		group.addChildAt( newSprite, group.numChildren );
 		
 		return m_image;
 	}
@@ -407,4 +412,32 @@
 	 
 	   return newDOC;
 	}
+	
+	public function print():Void
+	{
+		trace( "Group: " + debugName );
+		trace( "Position: (" + group.x + ", " + group.y + ")" );
+		trace( "Dimensions: " + group.width + " " + group.height );
+		trace( "visible: " + group.visible );
+		trace( "alpha: " + group.alpha );
+		trace( "group parent: " + group.parent );
+		trace( "mask: " + group.mask );
+		for ( child in group.__children )
+		{
+			trace( "\t" + child );
+			trace( "\t\t Position: (" + child.x + ", " + child.y + ")" );
+			trace( "\t\t Dimensions: " + child.width + " " + child.height );
+			trace( "\t\t visible: " + child.visible );
+			trace( "\t\t alpha: " + child.alpha );
+			
+			if ( Std.is( child, OPSprite ) && !Std.is( child, GraphicButton ) )
+			{
+				var img:OPSprite = cast child;
+				trace( "\t\t bitmap:" + img.bitmapData );
+				trace( "\t\t bitmap:" + img.getBitmap().name );
+				trace( "\t\t sprite mask: " + img.mask );
+				
+			}
+		}
+	}
 }
\ No newline at end of file
Index: Engineering/src/game/ui/VirtualScrollingMenu.hx
===================================================================
--- Engineering/src/game/ui/VirtualScrollingMenu.hx	(revision 832)
+++ Engineering/src/game/ui/VirtualScrollingMenu.hx	(working copy)
@@ -32,12 +32,12 @@
  */
 class ScrollingData
 {
-	public var imgSrc(default, null):Option< String >; // bitmap src URL
+	public var imgSrc(default, null):Option< Bitmap >; // bitmap src URL
 	public var primaryButtonSrc(default, null):Option< Bitmap >;
 	public var secondaryButtonSrc(default, null):Option< Bitmap >; 
 	public var label(default, null):Option< String >;  // text used to populate scrolling item label
 	
-	public function new( ?img:String, ?pBtn:Bitmap, ?sBtn:Bitmap, ?lbl:String )
+	public function new( ?img:Bitmap, ?pBtn:Bitmap, ?sBtn:Bitmap, ?lbl:String )
 	{
 		imgSrc = (img != null) ? Some(img):None;
 		primaryButtonSrc = (pBtn != null) ? Some(pBtn):None;
@@ -96,6 +96,7 @@
 	private var m_orientation:Orientation; // Horizontal or vertical
 	private var m_itemSpacing:Float; // Pixels - Vertical/horizontal space between item placement, depending on orientation. Includes item size + padding.
 	private var m_itemSize:Float; // Pixels - Horizontal = width, vertical = height. List assumes uniform items.
+	private var m_paistRef:DisplayObjectContainer; // Keep main ref for redrawing items
 	
 	// Movement helpers
 	private var m_isMouseDown:Bool;
@@ -117,9 +118,6 @@
 	private var m_scrollBar:OPSprite;
 	private var m_scrollTrack:OPSprite;
 	
-	
-	
-	
 	/**
 	 * Setup requires: 
 	 * 		- two example groups of display objects for reference
@@ -192,6 +190,7 @@
 		// - Start & End pos
 		// - List of scrolling items
 		// ---------------------------------------------------
+		m_paistRef = refGroup1;
 		addRef( refGroup1, refGroup2 );
 		
 		// ---------------------------------------------------
@@ -241,9 +240,21 @@
 			case VERTICAL:   refGroup1.y = m_startPos;
 		}
 		
+		populateScrollingItems();
+		
+		// Hide ref when we're done using it
+		refGroup1.visible = false; 
+		refGroup2.visible = false;
+	}
+	
+	private function populateScrollingItems()
+	{
 		// Populate scrollingItems using the visible item number. 
 		// Number of virtually scrolling display objects should be 1 + visibleItems 
 		//		( All that are visible and one just below view; list display starts off at the top)
+		var startX:Float = m_paistRef.x;
+		var startY:Float = m_paistRef.y;
+		
 		var numItems:Int = m_visibleItems + 1;
 		var count:Int = 0;
 		
@@ -254,13 +265,13 @@
 			{
 				switch( m_orientation )
 				{
-					case HORIZONTAL: refGroup1.x += m_itemSpacing;
-					case VERTICAL:   refGroup1.y += m_itemSpacing;
+					case HORIZONTAL: m_paistRef.x += m_itemSpacing;
+					case VERTICAL:   m_paistRef.y += m_itemSpacing;
 				}
 			}
 
 			// Create & add scrolling item
-			var item = new VirtualScrollingItem( refGroup1, count );
+			var item = new VirtualScrollingItem( m_paistRef, count );
 			m_scrollingItems.push( item );
 			
 			// Add mask to scrolling item
@@ -272,9 +283,8 @@
 			count++;
 		}
 		
-		// Hide ref when we're done using it
-		refGroup1.visible = false; 
-		refGroup2.visible = false;
+		m_paistRef.x = startX;
+		m_paistRef.y = startY;
 	}
 	
 	/**
@@ -289,7 +299,8 @@
 		start();
 		
 		// Hide scroll bar if it is not needed
-		if ( m_visibleItems >= m_dataset.length )
+		var haveScrollUI:Bool = m_scrollBar != null && m_scrollTrack != null;
+		if ( haveScrollUI && (m_visibleItems >= m_dataset.length) )
 		{
 			m_scrollBar.visible = false;
 			m_scrollTrack.visible = false;
@@ -339,7 +350,7 @@
 	/**
 	 * Adds data to virtual scrolling menu, to be populated onto objects
 	 */
-	public function addData( imgSrc:String, pBtnSrc:Bitmap, sBtnSrc:Bitmap, lbl:String )
+	public function addData( imgSrc:Bitmap, pBtnSrc:Bitmap, sBtnSrc:Bitmap, lbl:String )
 	{
 		var data:ScrollingData = new ScrollingData( imgSrc, pBtnSrc, sBtnSrc, lbl );
 		m_dataset.push( data );
@@ -350,7 +361,14 @@
 	 */
 	private function atUpperScrollLimit():Bool
 	{
-		return ( (scrolledOneItemForward() && m_userPos <= 0) );
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot detect upper scroll limits; no data available." );
+			return true;
+		}
+		
+		return ( scrolledOneItemForward() && m_userPos <= 0);
 	}
 	
 	/**
@@ -358,6 +376,13 @@
 	 */
 	private function atLowerScrollLimit():Bool
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot detect lower scroll limits; no data available." );
+			return true;
+		}
+		
 		var lastDataPos:Int = m_dataset.length - 1;
 		return  scrolledOneItemBackward() && ( m_userPos >= (lastDataPos - m_visibleItems ) );
 	}
@@ -424,6 +449,13 @@
 	 */
 	private function scrolledOneItemForward():Bool
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot scroll forward. No items in scrolling list." );
+			return false;
+		}
+		
 		var firstItem:VirtualScrollingItem = m_scrollingItems[ 0 ];
 		return ( firstItem.pos(m_orientation) >= m_upperScrollLimit);
 	}
@@ -434,6 +466,13 @@
 	 */
 	private function scrolledOneItemBackward():Bool
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot scroll backward. No items in scrolling list." );
+			return false;
+		}
+		
 		var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
 		return ( lastItem.pos( m_orientation ) + m_itemSize <= m_lowerScrollLimit );
 	}
@@ -444,6 +483,13 @@
 	 * */
 	private function repositionAtStart():VirtualScrollingItem
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot reposition items at start of list. No items in scrolling list." );
+			return null;
+		}
+		
 		var lastItem:VirtualScrollingItem = m_scrollingItems.pop();
 		var firstItem:VirtualScrollingItem = m_scrollingItems[ 0 ];
 		
@@ -460,6 +506,13 @@
 	 * */
 	private function repositionAtEnd():VirtualScrollingItem
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot reposition items at end of list. No items in scrolling list." );
+			return null;
+		}
+		
 		var firstItem:VirtualScrollingItem = m_scrollingItems.shift();
 		var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
 		
@@ -579,7 +632,6 @@
 		m_overPos = pos;
 		
 		m_direction = getDirection( distance );
-		
 		// ----------------------------------------------------------
 		// Early return if we are scrolling towards respective limits
 		// ----------------------------------------------------------
@@ -784,6 +836,17 @@
 	
 	private function dispose():Void
 	{
+		removeScrollListeners();
+		
+		// Clear menu
+		clearData();
+		
+		// Remove event listeners from menu
+		this.removeEventListener( Event.REMOVED_FROM_STAGE, onRemoved );
+	}
+	
+	private function removeScrollListeners():Void
+	{
 		// Remove listeners from the scroll interaction sprite
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_UP, onMouseUp ); 
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_DOWN, onMouseDown ); 
@@ -790,15 +853,52 @@
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove );
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_OUT, onMouseOut);
 		m_scrollArea.removeEventListener( Event.ENTER_FRAME, onFrame );
+	}
+	
+	/**
+	 * Clears scroll data for reinitialization. 
+	 */
+	public function reset():Void
+	{
+		m_paistRef.visible = true;
 		
-		// Remove listeners from items
-		// Clear items
+		clearData();
+	}
+	
+	/**
+	 * To be called after clearing data; at the moment used for search functionality
+	 */
+	public function reInit()
+	{
+		populateScrollingItems();
+		init();
+		
+		// Clear list if there is no data
+		if ( m_dataset.length < 1 )
+		{
+			clearData();
+			Debug.log( "No data availabile on reinitialization." );
+		}
+		
+		m_paistRef.visible = false;
+	}
+	
+	/**
+	 * Clears scroll data and display objects from the menu. Also removes event listeners.
+	 */
+	private function clearData():Void
+	{
+		m_isTweening = false;
+		removeScrollListeners();
+		
+		m_userPos = 0;
+		m_dataset = [];
+		
 		for ( item in m_scrollingItems )
 		{
 			item.clear();
 		}
 		
-		// Remove event listeners from menu
-		this.removeEventListener( Event.REMOVED_FROM_STAGE, onRemoved );
+		m_scrollingItems = [];
 	}
 }
\ No newline at end of file
