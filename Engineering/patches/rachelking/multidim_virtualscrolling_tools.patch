Index: src/game/Country.hx
===================================================================
--- src/game/Country.hx	(revision 829)
+++ src/game/Country.hx	(working copy)
@@ -14,12 +14,9 @@
 package game;
 import game.SocialIssue;
 
-/**
- * Class that holds the data tied to specific countries that we need for game logic.
- */
+
 class Country
 {
-	public var id(default, null):Int;
 	public var name(default, null):String; 
 	public var socialIssues(default, null):Array<SocialIssue>; // Description & charity for relevant social issues in the country/
 	public var population(default, null):Int; 
@@ -27,46 +24,17 @@
 	public var code(default, null):String; // Country code
 	public var coverImage(default, null):String; // Image used in an informational color page (URL)
 	public var flagImage(default, null):String; // Image used in flag game, country list (URL)
+	public var languages(default, null):String;
 	public var wish(default, null):String; // Phrase said when serving a meal; "Enjoy your meal!" etc. Displayed in Recipe Serving page.
 	public var recipes(default, null):Array<Recipe>; // List of recipes attributed to this country.
+	public var music(default, null):String; // Music to play in country page, country recipe pages. (URL)
 	public var facts(default, null):Array<String>;
-	public var music(default, null):String; // Music to play in country page, country recipe pages. (URL)
-	public var greetingAudio(default, null):String;  // URL of the "greeting" audio for this country
-	public var mealAudio(default, null):String;  // URL of the "bon apetite" audio for this country
+	public var mealAudio:String = null;
+	public var greetingAudio:String = null;
+	public var id = 1;
 	
-	/**
-	 * Constructor for the game logic version of a Country.
-	 * @param	id
-	 * @param	name
-	 * @param	socialIssues
-	 * @param	population
-	 * @param	capital
-	 * @param	code
-	 * @param	coverImage
-	 * @param	flagImage
-	 * @param	wish
-	 * @param	recipes
-	 * @param	facts
-	 * @param	music
-	 * @param	greetingAudio
-	 * @param	mealAudio
-	 */
-	public function new(id:Int, 
-		name:String, 
-		socialIssues:Array<SocialIssue>, 
-		population:Int, 
-		capital:String, 
-		code:String, 
-		coverImage:String, 
-		flagImage:String, 
-		wish:String, 
-		recipes:Array<Recipe>, 
-		facts:Array<String>,
-		music:String, 
-		greetingAudio:String,
-		mealAudio:String)
+	public function new(name, socialIssues, population, capital, code, coverImage, flagImage, languages, wish, recipes, music, facts)
 	{
-		this.id = id;
 		this.name = name;
 		this.socialIssues = socialIssues;
 		this.population = population;
@@ -74,12 +42,11 @@
 		this.code = code;
 		this.coverImage = coverImage;
 		this.flagImage = flagImage;
+		this.languages = languages;
 		this.wish = wish;
 		this.recipes = recipes;
 		this.music = music;
 		this.facts = facts;
-		this.greetingAudio = greetingAudio;
-		this.mealAudio = mealAudio;
 	}
 	
 	public static function sort( a:Country, b:Country ):Int
Index: src/game/DataManager.hx
===================================================================
--- src/game/DataManager.hx	(revision 829)
+++ src/game/DataManager.hx	(working copy)
@@ -15,22 +15,10 @@
 package game;
 import com.firstplayable.hxlib.Debug;
 import game.DataManager.ContentData;
-import game.Step.StepTypes;
 import game.def.RecipeTypes;
 import game.def.GradeDefs;
 import game.def.GradeDefs.PlayerGrade;
 import game.events.DataLoadedEvent;
-import game.net.DatabaseInterface;
-import game.net.schema.CountryAudioDef;
-import game.net.schema.CountryDef;
-import game.net.schema.DietaryPreferenceDef;
-import game.net.schema.GameDef;
-import game.net.schema.GameOptionDef;
-import game.net.schema.IngredientDef;
-import game.net.schema.MealTypeDef;
-import game.net.schema.RecipeDef;
-import game.net.schema.SocialIssueDef;
-import game.net.schema.ToolDef;
 import haxe.Json;
 import openfl.utils.AssetType;
 import com.firstplayable.hxlib.loader.ResMan;
@@ -63,31 +51,11 @@
 		this.mathQuestions = new Array();
 	}
 	
-	/**
-	 * Inits the game logic data from data loaded from the database backend via DatabaseInterface
-	 * @return
-	 */
 	public function init():EnumValue
 	{
-		// Parse data
-		getAllIngredients();
-		getAllRecipes();
-		getAllCountries();
-		getMathQuestions();
+		// Load JSON data. On completion, members will be populated with game content.
+		loadJson(); 
 		
-		// Load save using new data
-		SpeckGlobals.saveProfile.get();
-		
-		if (SpeckGlobals.saveProfile.gradeLevel == null)
-		{
-			//TODO: we will want this logic to happen in the login instead.
-			//Here we just default to grade 1
-			SpeckGlobals.saveProfile.setGradeLevel(GRADE_1);
-		}
-		
-		// Let others know we've finished
-		SpeckGlobals.event.dispatchEvent(new DataLoadedEvent());
-		
 		return null; // TODO - success/failure error enum
 	}
 
@@ -214,559 +182,459 @@
 		return false;
 	}
 	
-	//===============================================================
-	// Loads game data from the database backend
-	//===============================================================
+	// ----------------------------------------------------------------
+	// JSON RUNTIME CONTENT PARSING (TODO - REMOVE WHEN BACKEND SET UP) 
+	// ----------------------------------------------------------------
+	// Countries:  Line 116
+	// Ingredients: Line 214
+	// Recipes: 236
+	// ----------------------------------------------------------------
 	
-	/*
-	 * Stitches together data from the database to create a map of the ingredients
-	 * in a form used by the rest of the game.
-	 * @return
-	 */
-	private function getAllIngredients():Map<String, Ingredient>
+	// Callback for loadJson(); parses data once everything's been loaded to the network. 
+	private function onLoadComplete():Void
 	{
-		//TODO: this is a non-ideal way to do this.
-		//When api is given support for returning ingredients directly
-		//we can do this smarter.
-		allIngredients = new Map<String, Ingredient>();
+		// Parse data
+		getAllIngredients();
+		getAllRecipes();
+		getAllCountries();
+		getMathQuestions();
 		
-		var dbRecipes:Array<RecipeDef> = cast DatabaseInterface.ms_tableData[RECIPES];
-		for (recipe in dbRecipes)
+		// Load save using new data
+		SpeckGlobals.saveProfile.get();
+		
+		if (SpeckGlobals.saveProfile.gradeLevel == null)
 		{
-			var dbIngredients:Array<IngredientDef> = recipe.ingredients;
-			for (ingredient in dbIngredients)
-			{
-				var name:String = ingredient.name;
-				var spotlight:String = ingredient.tip; // Is this the data we want?
-				//we are not using units or amounts here since they are baked into the title.
-				var newIngredient:Ingredient = new Ingredient(name, spotlight);
-				allIngredients.set(newIngredient.name, newIngredient);
-			}
+			//TODO: we will want this logic to happen in the login instead.
+			//Here we just default to grade 1
+			SpeckGlobals.saveProfile.setGradeLevel(GRADE_1);
 		}
 		
-		return allIngredients;
+		// Let others know we've finished
+		SpeckGlobals.event.dispatchEvent(new DataLoadedEvent());
 	}
-	
-	/**
-	 * Stitches together data from the database to create a map of the recipes
-	 * in a form used by the rest of the game.
-	 * @return
-	 */
-	private function getAllRecipes():Map<String, Recipe>
+		
+	// To populate this.allCountries Combines country table data with other subtables.
+	// All country table schema: [Key, <unused>, <unused>, Population, Capital, Code, Cover image, Flag image, Languages, Name, Wish]
+	private function getAllCountries():Map<String, Country>
 	{
-		allRecipes = new Map<String, Recipe>();
+		// Grab relevant JSON data
+			// All countries
+		var countryText = ResMan.instance.getText("AllCountries");
+		var countryData:ContentData = haxe.Json.parse(countryText);
+		//Debug.dump( Type.typeof( countryData ) );
 		
-		var countriesByID:Map<Int, CountryDef> = new Map<Int, CountryDef>();
-		var dbCountries:Array<CountryDef> = cast DatabaseInterface.ms_tableData[COUNTRIES];
-		for (country in dbCountries)
-		{
-			countriesByID[country.id] = country;
-		}
+			// Country charities/social issues (for "Did You Know?")
+		var charityText = ResMan.instance.getText("CountryCharity");
+		var charityData:ContentData = Json.parse(charityText);
+		//Debug.dump( Type.typeof( charityData ) );
 		
-		var dbRecipes:Array<RecipeDef> = cast DatabaseInterface.ms_tableData[RECIPES];
-		for (recipe in dbRecipes)
+			// Country Facts
+		var factText = ResMan.instance.getText("CountryFact");
+		var factData:ContentData = Json.parse(factText);
+		//Debug.dump( Type.typeof( factData ) );
+		
+			// Country Recipe
+		var recipeText = ResMan.instance.getText("CountryRecipe");
+		var recipeData:ContentData = Json.parse(recipeText);
+		//Debug.dump( Type.typeof( recipeData ) );
+		
+		for (rowIdx in 0...countryData.rows.length)
 		{
-			var name:String = recipe.name;
-			if (name != null)
-			{
-				var id:Int = recipe.id;
-				
-				var presentation:String = recipe.presentation;
-				var tools:Array<Tool> = getToolDataFromRecipe(recipe);
-				
-				var ingredients:Array<Ingredient> = getIngredientsFromRecipe(recipe);
-				
-				var types:Array<RecipeTypes> = getRecipeTypesFromRecipe(recipe);
-				if (types == null)
-				{
-					Debug.log("unsupported recipe types in recipe #" + id + ": " + name);
-					//don't include this recipe
-					continue;
-				}
-				
-				var steps:Array<Step> = getStepsFromRecipe(recipe);
-				
-				var dbImages:Array<String> = getImagesFromRecipe(recipe);
-				var image:String = "";
-				if (dbImages.length > 0)
-				{
-					image = dbImages[0];
-				}
-				if (!countriesByID.exists(recipe.country_id))
-				{
-					Debug.log("no country with ID: " + recipe.country_id);
-					continue;
-				}
-				var country:String = countriesByID[recipe.country_id].name;
-				
-				var r = new Recipe(id, name, presentation, country, image, ingredients, tools, steps, types);
-				allRecipes.set(name, r);
-			}
+			var row:Array<Dynamic> = countryData.rows[rowIdx];
 			
+			var name:String = row[9];
+			var population:Int = row[3];
+			var capital:String = row[4];
+			var code:String = row[5];
+			var cover:String = row[6];
+			var flag:String = row[7]; 
+			var music:String = ""; // TODO
+			var language:String = row[8];
+			var wish:String = row[10];
+			var socialIssues:Array<SocialIssue> = getCountryIssues(name, charityData);
+			var facts:Array<String> = getCountryFacts(name, factData);
+			var recipes:Array<Recipe> = getCountryRecipes(name, recipeData);
+			
+			var c:Country = new Country(name, socialIssues, population, capital, code, cover, flag, language, wish, recipes, music, facts);
+			allCountries.set(name, c);
+			// trace("Country added: " + c);
 		}
 		
-		return allRecipes;
+		return allCountries;
 	}
 	
-	/**
-	 * Gets the game logic version of the recipe ingredients from the database
-	 * PRE: assumes that allIngredients has been populated.
-	 * @param	recipe
-	 * @return
-	 */
-	private function getIngredientsFromRecipe(recipe:RecipeDef):Array<Ingredient>
+	// Gets social issues for a given country. 
+	// Country charity table schema: [Country name, Country ID, Social issue description, Charity URL]
+	private function getCountryIssues(name:String, charityData:ContentData):Array<SocialIssue>
 	{
-		var ingredients:Array<Ingredient> = [];
-		for (ingredient in recipe.ingredients)
+		var issues:Array<SocialIssue> = new Array();
+		
+		for (rowIdx in 0...charityData.rows.length)
 		{
-			var nextIngredient:Ingredient = allIngredients.get(ingredient.name);
-			if (nextIngredient == null)
+			var row:Array<Dynamic> = charityData.rows[rowIdx];
+			if (name == row[0])
 			{
-				Debug.warn("somehow ingredient didn't exist in allInredients: " + ingredient.name);
-				continue;
+				var s = new SocialIssue(row[2], row[3]);
+				issues.push(s);
 			}
-			
-			ingredients.push(nextIngredient);
 		}
 		
-		return ingredients;
+		return issues; 
 	}
 	
-	/**
-	 * Gets the game logic version of the recipe types from the database
-	 * @param	recipe
-	 * @return
-	 */
-	private function getRecipeTypesFromRecipe(recipe:RecipeDef):Array<RecipeTypes>
+	// Gets facts for a given country. 
+	// Country facts table schema: [Country ID, Country name, Fact ID, Fact]
+	private function getCountryFacts(name:String, factData:ContentData):Array<String>
 	{
-		var types:Array<RecipeTypes> = [];
+		var facts:Array<String> = new Array();
 		
-		//Gets types from dietary_preferences
-		for (preference in recipe.dietary_preferences)
+		for (rowIdx in 0...factData.rows.length)
 		{
-			var nextType:RecipeTypes = translateRecipeTypeFromDietaryPreference(preference);
-			if (nextType == null)
+			var row:Array<Dynamic> = factData.rows[rowIdx];
+			if (row[1] == name)
 			{
-				//Missing a dietary preference is not dangerous if it's on a recipe
-				//since dietary preferences are always the absence of something
-				//never the presence of something
-				continue;
+				facts.push(row[3]);
 			}
-			types.push(nextType);
 		}
 		
-		//Gets types from meal_types
-		for (mealType in recipe.meal_types)
+		return facts;
+	}
+	
+	// Get a list of recipes attributed to a given country.
+	// Country recipe schema: [CountryID, Country name, Recipe ID, Recipe name]
+	private function getCountryRecipes(name:String, recipeData:ContentData):Array<Recipe>
+	{
+		var recipes:Array<Recipe> = new Array();
+		
+		for (rowIdx in 0...recipeData.rows.length)
 		{
-			var nextType:RecipeTypes = translateRecipeTypeFromMealType(mealType);
-			if (nextType == null)
+			var row:Array<Dynamic> = recipeData.rows[rowIdx];
+			if (row[1] == name)
 			{
-				continue;
+				recipes.push(allRecipes.get(row[3]));
 			}
-			types.push(nextType);
 		}
 		
-		return types;
+		return recipes;
 	}
 	
-	/**
-	 * Returns the game logic version of a recipe type from the database
-	 * @param	type
-	 * @return
-	 */
-	private function translateRecipeTypeFromMealType(type:MealTypeDef):RecipeTypes
+	// Creates ingredient objects from data. Returns lookup map from ingredient name -> object (globally accesible ingredients list)
+	// Ingredient row vals: [name, spotlight]
+	private function getAllIngredients():Map<String, Ingredient>
 	{
-		var name:String = type.name;
+		var ingredientText = ResMan.instance.getText("AllIngredients");
+		var ingredientData:ContentData = haxe.Json.parse(ingredientText);
+		var ingredients:Map<String, Ingredient> = new Map();
 		
-		if (name == "Appetizer")
+		for (rowIdx in 0...ingredientData.rows.length)
 		{
-			return APPETIZERS;
+			var row:Array<Dynamic> = ingredientData.rows[rowIdx];
+
+			var name:String = row[4];
+			var spotlight:String = row[5]; 
+			var i:Ingredient = new Ingredient(name, spotlight);
+			//trace("Added ingredient: " + i.name);
+			
+			allIngredients.set(i.name, i);
+			//trace(allIngredients.get(i.name) + " added to allIngredients map.");
 		}
 		
-		if (name == "Breakfast")
-		{
-			return BREAKFAST;
-		}
-		
-		if (name == "Main Course")
-		{
-			return MAINCOURSE;
-		}
-		
-		if (name == "Dessert")
-		{
-			return DESSERT;
-		}
-		
-		Debug.log("unhandled meal type: " + name);
-		return null;
+		return allIngredients;
 	}
 	
-	/**
-	 * Returns the game logic version of a recipe type from the database
-	 * @param	type
-	 * @return
-	 */
-	private function translateRecipeTypeFromDietaryPreference(type:DietaryPreferenceDef):RecipeTypes
+	// To populate this.allRecipes. Combines recipe table data with other subtables.
+	// Recipe table data: [Key, <unknown>, <unknown>, Country ID (recipes), Type, User (unused), Name, Presentation, Prep time, Country ID (Country), CountryName]
+	private function getAllRecipes():Map<String, Recipe>
 	{
-		var name:String = type.name;
-
-		if (name == "Vegetarian")
-		{
-			return VEGETARIAN;
-		}
+		// Grab relevant JSON data
+			// Steps 
+		var stepsText = ResMan.instance.getText("RecipeSteps");
+		var stepsData:ContentData = haxe.Json.parse(stepsText);
 		
-		if (name == "Dairy Free")
-		{
-			return DAIRYFREE;
-		}
+			// Tools
+		var allTools:Map<String, Tool> = getAllTools();
+		var toolText = ResMan.instance.getText("RecipeTools");
+		var toolData:ContentData = Json.parse(toolText);
 		
-		if (name == "Gluten Free")
+			// Types
+		var typesText = ResMan.instance.getText("RecipeTypes");
+		var typesData:ContentData = Json.parse(typesText);
+		
+			// Ingredients
+		var ingredientsText = ResMan.instance.getText("RecipeIngredients");
+		var ingredientsData:ContentData = Json.parse(ingredientsText);
+			
+			// Image
+		var imageText = ResMan.instance.getText("RecipeImage");
+		var imageData:ContentData = Json.parse(imageText);
+		
+			// All recipes 
+		var recipeText = ResMan.instance.getText("AllRecipes");
+		var recipeData:ContentData = Json.parse(recipeText);
+		
+		// Format data into recipe objects
+		for (rowIdx in 0...recipeData.rows.length)
 		{
-			return GLUTENFREE;
+			var row:Array<Dynamic> = recipeData.rows[rowIdx];
+
+			var name:String = row[6];
+			if (name != null) 
+			{
+				var presentation:String = row[7];
+				var tools:Array<Tool> = getRecipeTools(name, allTools, toolData);
+				var ingredients:Array<Ingredient> = getRecipeIngredients(name, ingredientsData);
+				var types:Array<RecipeTypes> = getRecipeTypes(name, typesData);
+				var steps:Array<Step> = getRecipeSteps(name, stepsData);
+				var image:String = getRecipeImage(name, imageData);
+				var country:String = row[10];
+				var r = new Recipe(name, presentation, country, image, ingredients, tools, steps, types);
+
+				allRecipes.set(name, r);
+				//trace("Recipe added to allrecipes: " + allRecipes.get(r.name));
+				
+			}
 		}
 		
-		Debug.log("unhandled dietary preference: " + name);
-		return null;
+		return allRecipes;
 	}
 	
-	/**
-	 * Gets game logic versions of the recipe steps from the database
-	 * @param	recipe
-	 * @return
-	 */
-	private function getStepsFromRecipe(recipe:RecipeDef):Array<Step>
+	// Creates tool objects from data. Returns lookup map from toolname -> tool object. 
+	// Tool row vals: [Key, <unused/null>, <unused/null>, Name, URL]
+	private function getAllTools():Map<String, Tool>
 	{
-		var steps:Array<Step> = [];
+		var toolText = ResMan.instance.getText("AllTools");
+		var toolData:ContentData = haxe.Json.parse(toolText);
+		var tools:Map<String, Tool> = new Map();
 		
-		for (step in recipe.steps)
+		for (rowIdx in 0...toolData.rows.length)
 		{
-			var stepNumber:Int = steps.length;
-			var stepType:StepTypes = translateStepTypeFromDatabase(step.type);
-			var instruction:String = step.text;
-			var nextStep:Step = new Step(stepNumber, stepType.getIndex(), instruction);
-			steps.push(nextStep);
+			var row:Array<Dynamic> = toolData.rows[rowIdx];
+
+			// Grab name [3] and URL [4]
+			var t:Tool = new Tool(row[3], row[4]);
+			
+			// Add to map so we can quickly grab them for recipe creation.
+			tools.set(t.name, t);
 		}
 		
-		return steps;
+		return tools;
 	}
 	
-	/**
-	 * Returns the game logic version of a recipe step type from the database
-	 * @param	type
-	 * @return
-	 */
-	private function translateStepTypeFromDatabase(type:String):StepTypes
+	// Gets ingredients for a given recipe, with measurements.
+	// Recipe + Ingredients + Unit table schema: [Recipename, Ingredientname, Amount, UnitID, Unitname]
+	private function getRecipeIngredients(name:String, data:ContentData):Array<Ingredient>
 	{
-		if (type == "Little chef")
+		var ingredients:Array<Ingredient> = new Array();
+		
+		for (rowIdx in 0...data.rows.length)
 		{
-			return LITTLECHEF;
+			var row:Array<Dynamic> = data.rows[rowIdx];
+
+			var rname = row[0];
+			if (rname == name)
+			{
+				var iname:String = row[1];
+				var amount:Float = row[2];
+				var Unit:String = row[4]; 
+				var i:Ingredient = allIngredients.get(iname);
+				var recipeIngredient:Ingredient = new Ingredient(i.name, i.spotlight, amount, Unit);
+				
+				ingredients.push(recipeIngredient);
+			}
 		}
-		else
-		{
-			//Default to big chef if not little chef
-			//Safer to make an adult to the step.
-			return BIGCHEF;
-		}
+		
+		return ingredients;
 	}
 	
-	/**
-	 * Gets game logic versions of the recipe images from the database
-	 * @param	recipe
-	 * @return
-	 */
-	private function getImagesFromRecipe(recipe:RecipeDef):Array<String>
-	{
-		var images:Array<String> = [];
-		for (image in recipe.images)
+	// Grabs recipe image URL. 
+	// Recipe image schema: [RecipeID, Recipe name, Recipe Presentation, Image URL]
+	private function getRecipeImage(name:String, data:ContentData):String
+	{		
+		var url:String = null;
+		
+		for (rowIdx in 0...data.rows.length)
 		{
-			var newImage:String = image.image;
-			images.push(newImage);
+			var row:Array<Dynamic> = data.rows[rowIdx];
+
+			if (row[1] == name)
+			{
+				url = row[3];
+			}
 		}
 		
-		return images;
+		return url;
 	}
 	
-	/**
-	 * Gets game logic versions of the tools used by a recipe
-	 * @return
-	 */
-	private function getToolDataFromRecipe(recipe:RecipeDef):Array<Tool>
-	{
-		var tools:Array<Tool> = [];
-		for (tool in recipe.tools)
+	// Returns array of tools used for a given recipe
+	// Recipe tools schema: [Recipe name, Tool name]
+	private function getRecipeTools(name:String, tools:Map<String, Tool>, data:ContentData):Array<Tool> 
+	{	
+		var recipeTools:Array<Tool> = new Array();
+		
+		for (rowIdx in 0...data.rows.length)
 		{
-			var newTool:Tool = translateToolFromDatabase(tool);
-			tools.push(newTool);
+			var row:Array<Dynamic> = data.rows[rowIdx];
+
+			if (row[0] == name)
+			{
+				recipeTools.push(tools.get(row[1]));
+			}
 		}
 		
-		return tools;
+		return recipeTools;
 	}
-	/**
-	 * Creates a game logic version of a social issue from a backend database version
-	 * @param	issue
-	 * @return
-	 */
-	private function translateToolFromDatabase(tool:ToolDef):Tool
+	
+	// Returns array of recipe types for a given recipe.
+	// Recipe types schema: [Recipe id, Recipe name, Type name, Type ID]
+	private function getRecipeTypes(name:String, data:ContentData):Array<RecipeTypes>
 	{
-		var name:String = tool.name;
-		var url:String = tool.url;
-		return new Tool(name, url);
-	}
+		var types:Array<RecipeTypes> = new Array();
 		
-	/**
-	 * Stitches together data from the database to create a map of the countries
-	 * in a form used by the rest of the game.
-	 * @return
-	 */
-	private function getAllCountries():Map<String, Country>
-	{
-		allCountries = new Map<String, Country>();
-		
-		//===========================================================
-		// Map of what audios each country has, which will be used to
-		// generate game logic country objects.
-		//===========================================================
-		var audiosByCountryId:Map<Int, Array<CountryAudioDef>> = new Map < Int, Array<CountryAudioDef>>();
-		var databaseAudios:Array<CountryAudioDef> = cast DatabaseInterface.ms_tableData[COUNTRY_AUDIOS];
-		for (audio in databaseAudios)
+		for (rowIdx in 0...data.rows.length)
 		{
-			if (!audiosByCountryId.exists(audio.country_id))
+			var row:Array<Dynamic> = data.rows[rowIdx];
+
+			if (row[1] == name)
 			{
-				audiosByCountryId[audio.country_id] = [];
+				var typeId:Int = row[3];
+				var typeEnum:RecipeTypes = Type.createEnumIndex( RecipeTypes, (typeId - 1) );
+				types.push(typeEnum);
 			}
-			audiosByCountryId[audio.country_id].push(audio);
 		}
 		
-		//===========================================================
-		// Map of what recipes each country has, which will be used to
-		// generate game logic country objects.
-		//===========================================================
-		var recipesByCountryId:Map<Int, Array<RecipeDef>> = new Map<Int, Array<RecipeDef>>();
-		var databaseRecipes:Array<RecipeDef> = cast DatabaseInterface.ms_tableData[RECIPES];
-		for (recipe in databaseRecipes)
-		{
-			if (!recipesByCountryId.exists(recipe.country_id))
-			{
-				recipesByCountryId[recipe.country_id] = [];
-			}
-			recipesByCountryId[recipe.country_id].push(recipe);
-		}
+		return types;
+	}
+
+	// Creates step objects for a specific recipe from data. Returns lookup from recipe name -> step array.
+	// Recipe/Step row vals: [Recipe ID, Recipe Name, Step ID, Step order, Step type, Step instruction]
+	private function getRecipeSteps(name:String, data:ContentData):Array<Step>
+	{
+		//var recipeSteps:Map< String, Array<Step> > = new Map();
+		//var recipeName:String;
+				
+		var steps:Array<Step> = new Array();
 		
-		//===========================================================
-		// Generate game logic country objects.
-		//===========================================================
-		var databaseCountries:Array<CountryDef> = cast DatabaseInterface.ms_tableData[COUNTRIES]; 
-		for (country in databaseCountries)
+		// Iterate through table linking recipes & recipe steps
+		for (rowIdx in 0...data.rows.length)
 		{
-			//========================================
-			// Pull together general country data
-			//========================================
-			var id:Int = country.id;
-			var name:String = country.name;
-			var population:Int = country.population;
-			var capital:String = country.capital;
-			var code:String = country.code;
-			var cover:String = country.country_image;
-			var flag:String = country.country_flag;
-			var wish:String = country.salutation;
+			var row:Array<Dynamic> = data.rows[rowIdx];
+
+			var order:Int;
+			var type:Null<Int> = row[4];
+			var dName:String = row[1]; // Recipe name associated with this step data.
 			
-			var socialIssues:Array<SocialIssue> = getSocialIssuesFromCountry(country);
-			var facts:Array<String> = getFactsFromCountry(country);
-			
-			var countryRecipes:Array<RecipeDef> = recipesByCountryId.get(id);
-			var recipes:Array<Recipe> = [];
-			
-			//Not all countries will have recipes!
-			if (countryRecipes != null)
+			// If it's a step for our recipe, add it to the list. 
+			if (dName == name)
 			{
-				for (dbRecipe in countryRecipes)
+				// Make a step object. If order is null. use step array index. 
+				if (row[3] == null) 
 				{
-					var newRecipe:Recipe = translateRecipeFromDatabase(dbRecipe);
-					if (newRecipe == null)
-					{
-						//somehow this failed...
-						//don't add the recipe
-						continue;
-					}
-					recipes.push(newRecipe);
-				}
-			}
-			
-			//========================================
-			// Pull together audio data
-			//========================================
-			var music:String = null;
-			var greeting:String = null;
-			var mealAudio:String = null;
-			
-			var allAudio:Array<CountryAudioDef> = audiosByCountryId.get(id);
-			if (allAudio != null)
-			{
-				//The audio schema is really weird.
-				//From what I can determine, audio info for countries is held
-				//separately in "country_audios" for some reason.
-				
-				//In the actual database, entries say which country they are the "greeting" audio for
-				//and also which country they are the "bon apetite" audio for.
-				//There seems to be no column for if they are "music" for a country.
-				
-				//There is another table called "musics" in the database.
-				//this just seems to be a list of files, with no way to figure out what they'e supposed to be.
-				//It is also empty.
-				
-				//Unfortunately, we can't even use all the country audio info, because the api only returns
-				//which country a given element belongs to, not what type of audio it is.
-				//For now we will just arbitrarily map the first sound as the music, the second as greeting,
-				
-				//TODO: FIX THIS when it's possible.
-				if (allAudio.length > 0)
+					order = steps.length - 1;
+				} 
+				else 
 				{
-					music = allAudio[0].file;
+					order = row[3];
 				}
-				if (allAudio.length > 1)
-				{
-					greeting = allAudio[1].file;
-				}
-				if (allAudio.length > 2)
-				{
-					mealAudio = allAudio[2].file;
-				}
+				var s:Step = new Step(order, type, row[5]);
+				steps.push(s);
 			}
-
-			//========================================
-			// Create the Country object
-			//========================================
-			var c:Country = new Country(id, name, socialIssues, population, capital, code, cover, flag, wish, recipes, facts, 
-				music, greeting, mealAudio);
-			allCountries.set(name, c);
 		}
 		
-		return allCountries;
+		return steps;
 	}
 	
-	/**
-	 * Creates game logic versions of Social Issues from the backend database version
-	 * @param	country
-	 * @return
-	 */
-	private function getSocialIssuesFromCountry(country:CountryDef):Array<SocialIssue>
+	// TODO - load/parse database content
+	private function getMathQuestions():Array< MultipleChoiceQuestion >
 	{
-		var issues:Array<SocialIssue> = [];
-		for (issue in country.social_issues)
-		{
-			var newIssue:SocialIssue = translateSocialIssueFromDatabase(issue);
-			issues.push(newIssue);
-		}
+		var q1:MultipleChoiceQuestion 
+			= new MultipleChoiceQuestion( "We have prepared 5 portions of food and we will share 4 portions with our friends. How many portions will we have left?",
+										  "5 - 4 = ?",
+										  [ "4", "9", "10" ],
+										  "1" );
+		var q2:MultipleChoiceQuestion 
+			= new MultipleChoiceQuestion( "We will share our food with 4 boys and 3 girls. How many kids are we going to share with?",
+										  "4 + 3 = ?",
+										  [ "3", "4", "8" ],
+										  "7" );
+		var q3:MultipleChoiceQuestion 
+			= new MultipleChoiceQuestion( "We are 5 friends who each want to eat 2 pieces of a delicious fruit, how many pieces of fruit do we have in total?",
+										  "5 * 2 = ?",
+										  [ "2", "3", "5" ],
+										  "10" );
+		var q4:MultipleChoiceQuestion 
+			= new MultipleChoiceQuestion( "We are 3 friends who each want to eat 4 pieces of a delicious fruit, how many pieces of fruit do we have in total?",
+										  "3 * 4 = ?",
+										  [ "9", "7", "10" ],
+										  "12" );
+		var q5:MultipleChoiceQuestion 
+			= new MultipleChoiceQuestion( "We have prepared 9 portions of food and we will share 2 portions with our friends. How many portions will we have left?",
+										  "9 - 2 = ?",
+										  [ "5", "4", "10" ],
+										  "7" );
+		mathQuestions.push(q1);
+		mathQuestions.push(q2);
+		mathQuestions.push(q3);
+		mathQuestions.push(q4);
+		mathQuestions.push(q5);
 		
-		return issues;
+		return mathQuestions;
 	}
 	
-	/**
-	 * Creates a game logic version of a social issue from a backend database version
-	 * @param	issue
-	 * @return
-	 */
-	private function translateSocialIssueFromDatabase(issue:SocialIssueDef):SocialIssue
+	// Gets JSON data to later parse; from set of exported database queries in assets/data
+	// TODO: HACKY. Remove once we get back-end hookup
+	private function loadJson():Void
 	{
-		var description:String = issue.issue;
-		var url:String = issue.url;
-		return new SocialIssue(description, url);
-	}
-	
-	/**
-	 * Creates game logic versions of Country Facts from the backend database version
-	 * @param	country
-	 * @return
-	 */
-	private function getFactsFromCountry(country:CountryDef):Array<String>
-	{
-		var facts:Array<String> = [];
-		for (fact in country.fact)
-		{
-			var newFact:String = fact.name;
-			facts.push(newFact);
-		}
+		var libname:String = "GAMECONTENT";
+		var rc:ResContext;
+ 		
+		// All Countries
+		rc = {src: "data/AllCountries.json", rename: "AllCountries"};
+		ResMan.instance.addRes(libname, rc);
 		
-		return facts;
-	}
-	
-	/**
-	 * Creates game logic versions of a Recipe from the backend database version
-	 * @param	country
-	 * @return
-	 */
-	private function translateRecipeFromDatabase(recipe:RecipeDef):Recipe
-	{
-		var receipeName:String = recipe.name;
-		var foundRecipe:Recipe = allRecipes.get(recipe.name);
-		if (foundRecipe == null)
-		{
-			Debug.log("recipe not found in allRecipes: " + recipe.name);
-		}
+		// All Ingredients
+		rc = {src: "data/AllIngredients.json", rename: "AllIngredients"};
+		ResMan.instance.addRes(libname, rc);
 		
-		return foundRecipe;
-	}
-	
-	/**
-	 * Stitches together data from the database to create a map of the math questions
-	 * in a form used by the rest of the game.
-	 * @return
-	 */
-	private function getMathQuestions():Array< MultipleChoiceQuestion >
-	{
-		mathQuestions = new Array<MultipleChoiceQuestion>();
+		// All Recipes 
+		rc = {src: "data/AllRecipesCountry.json", rename: "AllRecipes"};
+		ResMan.instance.addRes(libname, rc);
 		
-		var dbQuestions:Array<GameDef> = cast DatabaseInterface.ms_tableData[GAMES];
-		for (question in dbQuestions)
-		{
-			if (question.type != "math")
-			{
-				continue;
-			}
-			
-			var nextQuestion:MultipleChoiceQuestion = getMultipleChoiceQuestionFromDatabase(question);
-			mathQuestions.push(nextQuestion);
-		}
+		// All Tools 
+		rc = {src: "data/AllTools.json", rename: "AllTools"};
+		ResMan.instance.addRes(libname, rc);
+
+		// Country charities
+		rc = {src: "data/CountryCharity.json", rename: "CountryCharity"};
+		ResMan.instance.addRes(libname, rc);
 		
-		return mathQuestions;
-	}
-	
-	/**
-	 * Creates game logic versions of a MultipleChoiceQuestion from the backend database version
-	 * @param	question
-	 */
-	private function getMultipleChoiceQuestionFromDatabase(question:GameDef):MultipleChoiceQuestion
-	{
-		var wordedProblem:String = question.worded_question;
-		var mathProblem:String = question.question;
+		// Country facts
+		rc = {src: "data/CountryFact.json", rename: "CountryFact"};
+		ResMan.instance.addRes(libname, rc);
 		
-		var correctOption:String = translateMultipleChoiceOptionFromDatabase(question.correct_option);
+		// Country recipes
+		rc = {src: "data/CountryRecipe.json", rename: "CountryRecipe"};
+		ResMan.instance.addRes(libname, rc);
 		
-		var wrongOptions:Array<String> = [];
-		for (option in question.options)
-		{
-			//don't include the correct option
-			if (option.id == question.correct_option.id)
-			{
-				continue;
-			}
-			
-			var nextOption:String = translateMultipleChoiceOptionFromDatabase(option);
-			wrongOptions.push(nextOption);
-		}
+		// Recipe images
+		rc = {src: "data/RecipeImage.json", rename: "RecipeImage"};
+		ResMan.instance.addRes(libname, rc);
 		
-		var question:MultipleChoiceQuestion = new MultipleChoiceQuestion(wordedProblem, mathProblem, wrongOptions, correctOption);
-		return question;
+		// Recipe ingredients
+		rc = {src: "data/RecipeIngredientUnit.json", rename: "RecipeIngredients"};
+		ResMan.instance.addRes(libname, rc);
+		
+		// Recipe steps
+		rc = {src: "data/RecipeSteps.json", rename: "RecipeSteps"};
+		ResMan.instance.addRes(libname, rc);
+		
+		// Recipe tools
+		rc = {src: "data/RecipeTools.json", rename: "RecipeTools"};
+		ResMan.instance.addRes(libname, rc);
+		
+		// Recipe types 
+		rc = {src: "data/RecipeTypes.json", rename: "RecipeTypes"};
+		ResMan.instance.addRes(libname, rc);
+		
+		ResMan.instance.load(libname, onLoadComplete);
 	}
-	
-	/**
-	 * Creates game logic versions of a multiple choice option from the backend database version
-	 * @param	country
-	 * @return
-	 */
-	private function translateMultipleChoiceOptionFromDatabase(option:GameOptionDef):String
-	{
-		return option.value;
-	}
 }
\ No newline at end of file
Index: src/game/GameEventLog.hx
===================================================================
--- src/game/GameEventLog.hx	(revision 829)
+++ src/game/GameEventLog.hx	(working copy)
@@ -59,7 +59,7 @@
 	 */
 	private function onBrowserError(e:Error):Void
 	{
-		bugReport(e);
+		//bugReport(e);
 	}
 	#end
 	
Index: src/game/net/NetAssetLoader.hx
===================================================================
--- src/game/net/NetAssetLoader.hx	(revision 829)
+++ src/game/net/NetAssetLoader.hx	(working copy)
@@ -237,7 +237,7 @@
 	 */
 	private function onIOError(e:IOErrorEvent):Void
 	{
-		Debug.warn("IO Error: " + e);
+		//Debug.warn("IO Error: " + e);
         handleFailure();
 	}
 	
Index: src/game/Recipe.hx
===================================================================
--- src/game/Recipe.hx	(revision 829)
+++ src/game/Recipe.hx	(working copy)
@@ -16,7 +16,6 @@
 
 class Recipe
 {
-	public var id(default, null):Int; //database id of recipe
 	public var name(default, null):String; // Name of recipe
 	public var presentation(default, null):String; // Serving instructions for the dish
 	public var country(default, null):String; // Country of origin
@@ -26,9 +25,8 @@
 	public var steps(default, null):Array<Step>; // List of step-by-step preparation instructions
 	public var types(default, null):Array<RecipeTypes>; // Type/s of dish for menu and search filtering (see def.RecipeTypes)
 	
-	public function new(id:Int, name:String, presentation:String, country:String, image:String, ingredients:Array<Ingredient>, tools:Array<Tool>, steps:Array<Step>, types:Array<RecipeTypes>) 
+	public function new(name:String, presentation:String, country:String, image:String, ingredients:Array<Ingredient>, tools:Array<Tool>, steps:Array<Step>, types:Array<RecipeTypes>) 
 	{
-		this.id = id;
 		this.name = name;
 		this.presentation = presentation;
 		this.country = country;
Index: src/game/states/SplashState.hx
===================================================================
--- src/game/states/SplashState.hx	(revision 829)
+++ src/game/states/SplashState.hx	(working copy)
@@ -131,7 +131,7 @@
 		//================================================
 		//Populate remote CMS database data
 		//================================================
-		if ( URLUtils.didProvideAssessment() || URLUtils.didProvideAdmin() )
+		if ( true )//URLUtils.didProvideAssessment() || URLUtils.didProvideAdmin() )
 		{
 			// We are not loading the database in these views; skip this stage
 			postDatabaseInitialization();
@@ -223,9 +223,13 @@
 		// Indicate loading is complete
 		//==========================================
 		m_splashMenu.onLoadProgress(1);
-		
-		var id:Option<String> = URLUtils.getTeacherId();
-		StateManager.setState(GameState.TEACHER_ID_LOGIN,  {args: [id]});
+		
+		//var id:Option<String> = URLUtils.getTeacherId();
+		//StateManager.setState(GameState.TEACHER_ID_LOGIN,  {args: [id]});
+		
+		FlowController.data.selectedRecipe = SpeckGlobals.dataManager.allRecipes.get( "Spring Rolls" );
+		FlowController.data.selectedCountry = SpeckGlobals.dataManager.allCountries.get( "Vietnam" );
+		StateManager.setState( GameState.RECIPEINGREDIENTS, {args:[]});
 	}
 	
 	private function showMenu():Void
Index: src/game/ui/HudMenu.hx
===================================================================
--- src/game/ui/HudMenu.hx	(revision 830)
+++ src/game/ui/HudMenu.hx	(working copy)
@@ -733,6 +733,7 @@
 	
 	private function onMouseMove(e:MouseEvent):Void
 	{
+		/*
 		if (!m_zooming)
 		{
 			return;
@@ -775,10 +776,12 @@
 		//throw zoom event
 		var zoomRatio:Float = -zoomY / effectiveHeight;
 		SpeckGlobals.event.dispatchEvent(new ZoomEvent(zoomRatio));
+		*/
 	}
 	
 	public function resetZoomButton():Void
 	{
+		/*
 		var fullPanel:DisplayObject = getChildByName("pnl_fullHud");
 		var zoomButton:GraphicButton = getButtonById(ZOOM.getIndex());
 		var buttonBounds:Rectangle = zoomButton.getBounds(fullPanel);
@@ -787,26 +790,27 @@
 		var effectiveBottom = zoomBounds.bottom - (buttonBounds.height / 2);
 		
 		zoomButton.y = effectiveBottom; 
+		*/
 	}
 	
 	override public function onButtonDown( ?caller:GraphicButton ):Void
 	{
 		super.onButtonDown(caller);
-		
+		/*
 		if (caller.id == ZOOM.getIndex())
 		{
 			m_zooming = true;
-		}
+		}*/
 	}
 	
 	override public function onButtonUp( ?caller:GraphicButton ):Void
 	{
 		super.onButtonUp(caller);
-		
+		/*
 		if (caller.id == ZOOM.getIndex())
 		{
 			m_zooming = false;
 			m_zoomYStart = null;
-		}
+		}*/
 	}
 }
\ No newline at end of file
Index: src/game/ui/MultidimensionalScrollingMenu.hx
===================================================================
--- src/game/ui/MultidimensionalScrollingMenu.hx	(nonexistent)
+++ src/game/ui/MultidimensionalScrollingMenu.hx	(working copy)
@@ -0,0 +1,388 @@
+//
+// Copyright (C) 2017, 1st Playable Productions, LLC. All rights reserved.
+//
+// UNPUBLISHED -- Rights reserved under the copyright laws of the United
+// States. Use of a copyright notice is precautionary only and does not
+// imply publication or disclosure.
+//
+// THIS DOCUMENTATION CONTAINS CONFIDENTIAL AND PROPRIETARY INFORMATION
+// OF 1ST PLAYABLE PRODUCTIONS, LLC. ANY DUPLICATION, MODIFICATION,
+// DISTRIBUTION, OR DISCLOSURE IS STRICTLY PROHIBITED WITHOUT THE PRIOR
+// EXPRESS WRITTEN PERMISSION OF 1ST PLAYABLE PRODUCTIONS, LLC.
+///////////////////////////////////////////////////////////////////////////
+
+package game.ui;
+
+import com.firstplayable.hxlib.display.OPSprite;
+import game.Country;
+import game.ui.VirtualScrollingMenu.ScrollingData;
+import openfl.display.DisplayObjectContainer;
+import game.ui.VirtualScrollingMenu.Orientation;
+import game.ui.VirtualScrollingMenu.Direction;
+import com.firstplayable.hxlib.display.OPSprite;
+import openfl.display.Sprite;
+
+
+enum Dimension
+{
+	ROW;
+	COLUMN;
+}
+
+/**
+ *  A virtual scrolling menu that handles lists of multiple rows/columns.
+ *  Does its own setup, but adopts parent's movement/data functions
+ */
+class MultidimensionalScrollingMenu extends VirtualScrollingMenu
+{
+
+	private var m_visibleCols:Int;
+	private var m_colSpacing:Float;
+	private var m_visibleRows:Int;
+	private var m_rowSpacing:Float;
+	
+	
+	/**
+	 * @param	centerRef - top left object in a scrolling gred
+	 * @param	bottomRef - object directly below center ref 
+	 * @param	rightRef - object directly to the right of center ref 
+	 */
+	public function new( scrollBounds:OPSprite, orientation:Orientation, centerRef:DisplayObjectContainer, ?bottomRef:DisplayObjectContainer, ?rightRef:DisplayObjectContainer, ?scrollBar:OPSprite, ?scrollTrack:OPSprite )
+	{
+		super ( scrollBounds, orientation, null, null, scrollBar, scrollTrack );
+
+		m_userPos = -1;
+		// ---------------------------------------------------
+		// Init other member vars using paist ref:
+		// - Visisble items
+		// - Item spacing
+		// - Item size
+		// - Start & End pos
+		// - List of scrolling items
+		// ---------------------------------------------------
+		addMultiRef( centerRef, bottomRef, rightRef );
+		
+		// ---------------------------------------------------
+		// Add scroll bar/track, if applicable
+		// ---------------------------------------------------
+		addScrollUI( scrollBar, scrollTrack );
+	}
+	
+	private function addMultiRef( centerRef:DisplayObjectContainer, ?bottomRef:DisplayObjectContainer, ?rightRef:DisplayObjectContainer )
+	{
+		m_visibleCols = 1;
+		m_visibleRows = 1;
+		
+		// ---------------------------------------------------------
+		// Get relevant item dimension, based on scroll orientation
+		// 		This is used for bounds detection.
+		// ---------------------------------------------------------
+		switch ( m_orientation )
+		{
+			case Orientation.HORIZONTAL:
+			{
+				m_itemSize = centerRef.width;
+			}
+			
+			case Orientation.VERTICAL:
+			{
+				m_itemSize = centerRef.height;
+			}
+		}
+		
+		MAX_FRAME_DISTANCE = m_itemSize;
+		
+		// -------------------------------------------------------
+		// Get column spacing data, if applicable
+		// 		This is used when adding new columns in scrolling.
+		// -------------------------------------------------------
+		if ( rightRef != null )
+		{
+			m_colSpacing = rightRef.x - centerRef.x; // Includes item size + padding
+			m_visibleCols = Math.floor( m_scrollArea.width / m_colSpacing );
+		}
+		
+		// ----------------------------------------------------
+		// Get row spacing data, if applicable
+		//		This is used when adding new rows in scrolling.
+		// ----------------------------------------------------
+		if ( bottomRef != null )
+		{
+			m_rowSpacing = bottomRef.y - centerRef.y;
+			m_visibleRows = Math.floor( m_scrollArea.height / m_rowSpacing );
+		}
+		
+		// ----------------------------------------------------
+		// Populate a set of items based on above dimensions.
+		// Items are filled taking the scroll orientation into account, 
+		// 		such that the last row/col of items in the list are at the scroll end.
+		// ----------------------------------------------------
+		
+		m_visibleItems = m_visibleRows * m_visibleCols; // used for bounds checking
+		
+		var numRows:Int = m_visibleRows;
+		var numCols:Int = m_visibleCols;
+		var rowOffset:Float = m_rowSpacing;
+		var colOffset:Float = m_colSpacing;
+		var count:Int = 0;
+		
+		switch( m_orientation )
+		{	
+			case Orientation.HORIZONTAL:
+			{
+				numCols++; // Since we are adding new columns when scrolling, place an extra set out of view
+				var initXPos:Float = centerRef.x;
+				var initYPos:Float = centerRef.y;
+				rowOffset = initYPos;
+				colOffset = initXPos;
+				for ( col in 0...numCols )
+				{
+					rowOffset = initYPos;
+					
+					for ( row in 0...numRows)
+					{
+						var item:VirtualScrollingItem = new VirtualScrollingItem( centerRef, count );
+						//item.addMask( m_scrollArea );
+						item.setCoordinates( colOffset, rowOffset );
+						m_scrollingItems.push( item );
+						
+						rowOffset += m_rowSpacing;
+						count++; // Temp - debugging
+					}
+
+					colOffset += m_colSpacing;
+				}
+			}
+			case Orientation.VERTICAL:
+			{
+				numRows++; // Since we are adding new rows when scrolling, place an extra set out of view
+				var initXPos:Float = centerRef.x;
+				var initYPos:Float = centerRef.y;
+				rowOffset = initYPos;
+				colOffset = initXPos;
+				for ( row in 0...numRows)
+				{	
+					colOffset = initXPos;
+					
+					for ( col in 0...numCols )
+					{
+						var item:VirtualScrollingItem = new VirtualScrollingItem( centerRef, count );
+						//item.addMask( m_scrollArea );
+						item.setCoordinates( colOffset, rowOffset );
+						m_scrollingItems.push( item );
+
+						colOffset += m_colSpacing;
+						count++; // Temp - debugging
+					}
+					
+					rowOffset += m_rowSpacing;
+				}
+			}
+		}
+		
+		centerRef.visible = false;
+		bottomRef.visible = false;
+		rightRef.visible = false;
+		
+		trace( "Printing scrolling items list: " );
+		for ( item in m_scrollingItems )
+		{
+			trace( "\t" + item.debugName );
+		}
+	}
+	
+	// ===================================
+	// Object positioning helper functions
+	// ===================================
+	
+	/**
+	 * Checks if list & repopulates a scrolling item at the top or bottom as needed
+	 */
+	private override function handleVirtualReposition( dir:Direction ):Void 
+	{
+		var newItem:VirtualScrollingItem = null;
+		var dataIdx:Int = 0;
+		
+		// Early return if user is scrolling towards the end of the list
+		if ( scrollingAtLimit( m_direction ) )
+		{
+			return;
+		}
+		
+		switch( m_orientation )
+		{
+			case HORIZONTAL: // todo
+			case VERTICAL:
+			{
+				switch( dir )
+				{
+					case FORWARD:	
+					{
+						if ( scrolledOneItemForward() )
+						{
+							var newItems:Array< VirtualScrollingItem > = repositionSetAtStart();
+							//updateItemData( newItems, dir );
+						}
+					}
+					case BACKWARD:  
+					{
+						if ( scrolledOneItemBackward() )
+						{
+							var newItems:Array< VirtualScrollingItem > = repositionSetAtEnd();		
+							//updateItemData( newItems, dir );
+						}
+
+					}
+				}
+			}
+		}
+	}
+	
+	/**
+	 * Take the last items of the list and place it at the top
+	 * Returns reference to them for data updates.
+	 * */
+	private function repositionSetAtStart():Array< VirtualScrollingItem >
+	{
+		var firstRow:Array< VirtualScrollingItem > = new Array();
+		var lastRow:Array< VirtualScrollingItem > = new Array();
+		switch ( m_orientation )
+		{
+			case Orientation.VERTICAL:
+			{	
+				// Get the first row of the list 
+				for ( item in m_scrollingItems )
+				{
+					firstRow.push( item );
+				}
+				
+				// Get the the items in the last row
+				var idx:Int = m_scrollingItems.length - 1;
+				var count:Int = 0;
+				while ( count < m_visibleCols )
+				{
+					lastRow.push( m_scrollingItems[ idx ] );
+					idx--;
+					count++;
+				}
+				
+				trace( "updating two items at start:" );
+				for ( i in 0...m_visibleCols )
+				{
+					// Change item screen position
+					var firstRowItem:VirtualScrollingItem = firstRow[ i ];
+					var lastRowItem:VirtualScrollingItem = lastRow[ i ];
+					lastRowItem.setCoordinates( firstRowItem.posX(), firstRowItem.posY() - m_rowSpacing );
+					
+					// Update item's position in the array
+					m_scrollingItems.remove( lastRowItem ); // Remove from end (first instance of item)
+					m_scrollingItems.insert( 0, lastRowItem ); // Add to beginning
+					
+					// Update the item data
+					var dataIdx:Int = m_userPos;
+					lastRowItem.updateData( m_dataset[ dataIdx ] );
+					trace( m_dataset[ dataIdx ].label );
+					m_userPos -= 1;
+					trace( m_userPos );					
+				}
+			}
+			case HORIZONTAL:
+			{
+				// todo
+			}
+		}
+		
+		return null;
+	}
+	
+	/**
+	 * Take the first row  of the list and place it at the bottom
+	 * Returns reference to them for data updates.
+	 * */
+	private function repositionSetAtEnd():Array< VirtualScrollingItem >
+	{
+		var firstRow:Array< VirtualScrollingItem > = new Array();
+		var lastRow:Array< VirtualScrollingItem > = new Array();
+		switch ( m_orientation )
+		{
+			case VERTICAL:
+			{	
+				// Get the first row of the list 
+				for ( item in m_scrollingItems )
+				{
+					firstRow.push( item );
+				}
+				
+				// Get the the items in the last row
+				var idx:Int = m_scrollingItems.length - 1;
+				var count:Int = 0;
+				while ( count < m_visibleCols )
+				{
+					lastRow.push( m_scrollingItems[ idx ] );
+					idx--;
+					count++;
+				}
+				
+				trace( "updating two items at end:" );
+				for ( i in 0...m_visibleCols )
+				{
+					// Change item screen position
+					var firstRowItem:VirtualScrollingItem = firstRow[ i ];
+					var lastRowItem:VirtualScrollingItem = lastRow[ i ];
+					firstRowItem.setCoordinates( lastRowItem.posX(), lastRowItem.posY() + m_rowSpacing );
+					
+					// Update item's position in the array
+					m_scrollingItems.remove( firstRowItem ); // Remove from beginning (first instance of item)
+					m_scrollingItems.push( firstRowItem ); // Add to end
+					
+					// Update the item data
+					var dataIdx:Int = m_userPos + (m_visibleCols * 2);
+					firstRowItem.updateData( m_dataset[ dataIdx ] );
+					trace( m_dataset[ dataIdx ].label );
+					m_userPos += 1;
+					trace( m_userPos );
+				}
+			}
+			case HORIZONTAL:
+			{
+				// todo
+			}
+		}
+
+		return null;//firstRow; // now last row
+	}
+	
+	private function updateItemData( items:Array< VirtualScrollingItem >, dir:Direction )
+	{
+		var dataIdx:Int;
+		for ( item in items )
+		{
+			trace( "updating item: " );
+			switch ( dir )
+			{
+				case FORWARD:
+				{
+					dataIdx = m_userPos - m_visibleCols;
+					if ( ( dataIdx > 0 ) )
+					{
+						item.updateData( m_dataset[ dataIdx ] );
+						m_userPos--;
+						trace( "\t" + m_dataset[ dataIdx ].label );
+						trace( "\tForward:" + m_userPos );
+					}
+				}
+				case BACKWARD:
+				{	
+					dataIdx = m_userPos + m_visibleCols;
+					if (( dataIdx < m_dataset.length ))
+					{
+						item.updateData( m_dataset[ dataIdx ] );
+						m_userPos++;
+						trace( "\tBackward:" + m_dataset[ dataIdx ].label );
+						trace( m_userPos );
+					}
+				}
+			}
+		}
+	}
+}
\ No newline at end of file
Index: src/game/ui/states/MainMenu.hx
===================================================================
--- src/game/ui/states/MainMenu.hx	(revision 829)
+++ src/game/ui/states/MainMenu.hx	(working copy)
@@ -210,7 +210,7 @@
 	public function new() 
 	{
 		super( "MainMenu" );
-		
+	/*	
 		startTouchPoint = null;
 		startTouchTime = 0;
 		curTouchPoint = null;
@@ -228,6 +228,7 @@
 		m_curZoom = 0.0;
 
 		createAllCountryMenuData();
+		*/
 	}
 	
 	private function load3D():Void
@@ -371,7 +372,7 @@
 		}
 		else
 		{
-			Debug.log( "Logic error: Sphere rotate, but also had started a timeout to rotate, resetting timeout..." );
+			//Debug.log( "Logic error: Sphere rotate, but also had started a timeout to rotate, resetting timeout..." );
 			_sphereTimeoutStart = null;
 		}
 	}
@@ -403,7 +404,6 @@
 	private function onMouseDown(e:MouseEvent):Void
 	{
 		startTouchPoint = new Point(e.stageX, e.stageY);
-
 	}
 	
 	private function onMouseMove(e:MouseEvent):Void
Index: src/game/ui/states/RecipeIngredientsMenu.hx
===================================================================
--- src/game/ui/states/RecipeIngredientsMenu.hx	(revision 829)
+++ src/game/ui/states/RecipeIngredientsMenu.hx	(working copy)
@@ -28,7 +28,8 @@
 import game.controllers.FlowController;
 import game.def.GameState;
 import game.net.NetAssets;
-import game.ui.ScrollingManager;
+import game.ui.VirtualScrollingMenu;
+import game.ui.MultidimensionalScrollingMenu;
 import game.ui.SpeckMenu;
 import game.ui.states.RecipeIngredientsMenu.IngredientGroup;
 import game.ui.states.RecipeIngredientsMenu.ToolGroup;
@@ -70,19 +71,9 @@
  * */
 class RecipeIngredientsMenu extends SpeckMenu
 {
-	// ------ Static tunable vars:
-	// TODO - callback to pull from paist bounding box
-	private static inline var INGREDIENT_WIDTH:Float = 400;
-	private static inline var INGREDIENT_HEIGHT:Float = 390;
-	private static inline var INGREDIENT_NUM:Int = 6;
-	
-	private static inline var TOOL_WIDTH:Float = 700;
-	private static inline var TOOL_HEIGHT:Float = 90;
-	private static inline var TOOL_NUM:Int = 2;
-
 	// ------ Member vars:
-	private var m_ToolsMenu:ScrollingManager;
-	private var m_IngredientsMenu:ScrollingManager; 
+	private var m_ingredientsMenu:VirtualScrollingMenu; 
+	private var m_toolsMenu:MultidimensionalScrollingMenu;
 	
 	private var m_recipeImage:OPSprite;
 
@@ -90,34 +81,63 @@
 	{
 		super( "RecipeIngredientsMenu" );
 		
-		initData( p );
+		// Grab highlighted recipe for setting up img/favorites
+		var recipe:Recipe = FlowController.data.selectedRecipe;
+
+		// ---------------------------------------------------
+		// Set menu title
+		// ---------------------------------------------------
+		var title:TextField = cast getChildByName( "headerText" );
+		title.text = recipe.name; 
 		
-		m_recipeImage = null;
-	}
-	
-	public function dispose():Void
-	{
-		m_ToolsMenu.dispose();
-		m_IngredientsMenu.dispose();
+		// ---------------------------------------------------
+		// Set up the scrolling ingredients menu
+		// ---------------------------------------------------
+		var ingredientBounds:OPSprite = cast getChildByName( "spr_scrollBounds_ingredients" );
+		var ingredientScrollBar:OPSprite = cast getChildByName( "handleIngredients" );
+		var ingredientScrollTrack:OPSprite = cast getChildByName( "spr_scrollBacking_ingredients" );
+		var ingredientRef1:OPSprite = cast getChildByName( "group_ingredient1" );
+		var ingredientRef2:OPSprite = cast getChildByName( "group_ingredient2" );
 		
-		if (m_recipeImage != null)
-		{
-			removeChild(m_recipeImage);
-			m_recipeImage = null;
-		}
-	}
-	
-	public function initData( p:GameStateParams ):Void
-	{
-		// Pull relevant params data 
-		var recipe:Recipe = FlowController.data.selectedRecipe;
-		var country:Country = FlowController.data.selectedCountry;
+		// Set menu-specific button onHit
+		var ingredientRefButton:GraphicButton = cast ingredientRef1.getChildByName( "btn_ingredient1" );
+		ingredientRefButton.onHit = onIngredientHit;
 		
-		// Display recipe name as menu title
-		var header:TextField = cast this.getChildByName( "headerText" );
-		header.text = recipe.name;
+		m_ingredientsMenu = new VirtualScrollingMenu( ingredientBounds, Orientation.VERTICAL, ingredientRef1, ingredientRef2, ingredientScrollBar, ingredientScrollTrack );
 		
-		// Favoriting button is visible in the consumer flow
+		addIngredientData();
+		this.addChild( m_ingredientsMenu );
+		m_ingredientsMenu.init();
+		
+		// ---------------------------------------------------
+		// Set up the scrolling ingredients menu
+		// ---------------------------------------------------
+		var toolBounds:OPSprite = cast getChildByName( "spr_scrollBounds_tools" );
+		var toolScrollBar:OPSprite = cast getChildByName( "handleTools" );
+		var toolScrollTrack:OPSprite = cast getChildByName( "spr_scrollBacking_tools" );
+		var toolRef1:OPSprite = cast getChildByName( "group_tool1" );
+		var toolRef2:OPSprite = cast getChildByName( "group_tool2" );
+		var toolRef3:OPSprite = cast getChildByName( "group_tool3" );
+		
+		
+		
+		// Set menu-specific button onHit
+		var toolRefButton:GraphicButton = cast toolRef1.getChildByName( "btn_tool1" );
+		toolRefButton.onHit = onToolHit;
+		
+		var toolRef1:OPSprite = cast getChildByName( "group_tool1" );
+		var refLabel:TextField = cast toolRef1.getChildByName( "lbl_tool1" );			
+		
+		m_toolsMenu = new MultidimensionalScrollingMenu( toolBounds, Orientation.VERTICAL, toolRef1, toolRef3, toolRef2, toolScrollBar, toolScrollTrack );
+		
+		addToolData();
+		this.addChild( m_toolsMenu );
+		m_toolsMenu.init();
+		
+		// ---------------------------------------------------
+		// Set up the favorites button
+		// ---------------------------------------------------
+		// Favoriting button is only visible in the consumer flow
 		if ( FlowController.currentMode == FlowMode.CONSUMER )
 		{
 			// Show favorites button
@@ -139,29 +159,10 @@
 				fav.downState = ResMan.instance.getImage( "2d/Buttons/btn_favorites_up" );
 			}
 		}
-		
-		
-		// Get boundary for the scroll menus 
-		var iBounds:DisplayObjectContainer = cast this.getChildByName( "ingredient_bounds" );
-		var tBounds:DisplayObjectContainer = cast this.getChildByName( "tool_bounds" );
-		
-		// Create scroll menus
-		m_IngredientsMenu = new ScrollingManager( iBounds.x, iBounds.y, INGREDIENT_WIDTH, INGREDIENT_HEIGHT, this, "vertical", INGREDIENT_NUM );
-		m_ToolsMenu = new ScrollingManager( tBounds.x, tBounds.y, TOOL_WIDTH, TOOL_HEIGHT, this, "vertical", TOOL_NUM, 2 );
-		m_IngredientsMenu.addScrollBar( cast getChildByName( "handleIngredients" ), cast getChildByName( "spr_scrollBacking_ingredients" ) );
-		m_ToolsMenu.addScrollBar( cast getChildByName( "handleTools" ), cast getChildByName( "spr_scrollBacking_tools" ) );
 
-		// Populate the tools & ingredients from ref, for the respective scroll menus
-		createIngredients();
-		createTools();
-		
-		// Initialize scroll menus
-		m_IngredientsMenu.init();
-		m_ToolsMenu.init();
-		this.addChild( m_IngredientsMenu );
-		this.addChild( m_ToolsMenu );
-		
-		// Edit recipe image
+		// ---------------------------------------------------
+		// Set up the recipe image
+		// ---------------------------------------------------
 		var paistImg:OPSprite = cast getChildByName( "recipeImage" );
 		
 		if (Tunables.USE_DATABASE_RESOURCES)
@@ -191,17 +192,83 @@
 		{
 			var fileName:String = StringTools.replace( recipe.name, " ", "_" );
 			var recipeImg:Bitmap = ResMan.instance.getImageUnsafe( "2d/UI/recipesLarge/recipe_" + fileName + "_01" );
-			if ( recipeImg == null ) // TEMPORARY UNTIL DB HOOKUP: use placeholder image if no recipe image exists
+			if ( recipeImg == null ) // Use placeholder image if no recipe image exists
 			{
 				recipeImg = ResMan.instance.getImage( "2d/UI/recipesLarge/placeholder" );
 			}
 			updateRecipeImage(recipeImg);
 		}
+	}
+	
+	// ===================================
+	// Scroll setup 
+	// ===================================
+	
+	private function addIngredientData()
+	{
+		var recipe:Recipe = FlowController.data.selectedRecipe;
 		
-		// Make masks visible above scroll items
-		showMasks();
+		for ( ingredient in recipe.ingredients )
+		{
+			var label:String; 
+			var buttonImg:Bitmap;
+			
+			if (Tunables.USE_DATABASE_RESOURCES)
+			{
+				label = ingredient.name;
+			}
+			else
+			{
+				label = ingredient.amount + "- " + ingredient.unit + " " + ingredient.name; 
+			}
+			
+			if ( ingredient.spotlight != "" )
+			{
+				buttonImg = ResMan.instance.getImage( "2d/Buttons/btn_info_up" );
+			}
+			else
+			{
+				buttonImg = ResMan.instance.getImage( "2d/Buttons/btn_checkSmall_up" );
+				// TODO button.enabled = false; // Check "buttons" are not interactable.
+			}
+			
+			m_ingredientsMenu.addData( null, buttonImg, null, label );
+		}
 	}
 	
+	private function addToolData()
+	{
+		var recipe:Recipe = FlowController.data.selectedRecipe;
+	var count:Int = 0;
+		for ( tool in recipe.tools )
+		{
+			trace( "adding " + tool.name );
+			// Button
+			var buttonImg:Bitmap;
+			if ((tool.URL == null) || (tool.URL == ""))
+			{
+				buttonImg = ResMan.instance.getImage( "2d/Buttons/btn_store_disabled", false );
+			}
+			else
+			{
+				buttonImg = ResMan.instance.getImage( "2d/Buttons/btn_store_up", false );
+			}
+			
+			// Label to display the tool name 
+			var label:String;
+			label = Std.string( count ) ;
+			count++;
+			//label = tool.name;
+			var toolRef1:OPSprite = cast getChildByName( "group_tool1" );
+			var refLabel:TextField = cast toolRef1.getChildByName( "lbl_tool1" );
+			m_toolsMenu.addData( null, buttonImg, null, label );
+		}
+	}
+	
+	// ===================================
+	// Menu setup
+	// ===================================
+	
 	/**
 	 * Updates the image 
 	 * @param	image
@@ -247,6 +314,10 @@
 		m_recipeImage.y = paistImg.y - yOffset;
 	}
 	
+	// ===================================
+	// Button interaction 
+	// ===================================
+	
 	override public function onButtonHit( ?caller:GraphicButton ):Void 
 	{
 		super.onButtonHit( caller );
@@ -279,182 +350,31 @@
 			}
 			
 		}
-		else // Generated ingredient or tool button
-		{
-			var split:Array< String > = caller.name.split("_");
-			var type:String = split[0];
-			var name:String = split[1];
-		
-			if ( type == "ingredient" ) 
-			{
-				// Go to the ingredient info state
-				var selectedIngredient:Ingredient = SpeckGlobals.dataManager.allIngredients.get( name );
-				StateManager.setState( GameState.INGREDIENTINFO,  { args: [ GameState.RECIPEINGREDIENTS, selectedIngredient] } );
-			}
-			else if ( type == "tool" )
-			{
-				for ( tool in recipe.tools)
-				{
-					if ( tool.name == name )
-					{
-						goToUrl( tool.URL );
-						return;
-					}
-				}
-			}
-			else
-			{
-				trace( "Unknown button type." );
-			}
-		}
 	}
 	
-	private function createIngredients():Void
+	private function onIngredientHit( ?caller:GraphicButton ):Void
 	{
-		// Get paist item for display ref: Ingredients
-		var iPanel:DisplayObjectContainer = cast this.getChildByName( "group_ingredient1" );
-		var iLabel:TextField = cast iPanel.getChildByName( "lbl_ingredient1" );
-		var iButton:GraphicButton = cast iPanel.getChildByName( "btn_ingredient1" );
-		var ref:IngredientGroup = { panel: iPanel, label: iLabel, button: iButton, ingredient: null };
+		WebAudio.instance.play( "SFX/button_click" );	
 		
-		// Offset for incrementing list position
-		var offset:Float = 0;
-		
-		// Loop through this recipe's ingredients
-		for ( ingredient in FlowController.data.selectedRecipe.ingredients )
+		// Go to the ingredient info state
+		var selectedIngredient:Ingredient = SpeckGlobals.dataManager.allIngredients.get( caller.name );
+		if ( selectedIngredient.spotlight != "" )
 		{
-			// Holding panel
-			var panel:DisplayObjectContainer = new DisplayObjectContainer();
-			panel.x = ref.panel.x; 
-			panel.y = ref.panel.y + offset;
-			panel.name = ingredient.name;
-			panel.visible = true;
-			this.addChild( panel );
-			
-			// Label to display the ingredient name 
-			var label:TextField = new TextField();
-			if (Tunables.USE_DATABASE_RESOURCES)
-			{
-				label.text = ingredient.name;
-			}
-			else
-			{
-				label.text = ingredient.amount + " " + ingredient.unit + " " + ingredient.name; 
-			}
-			label.setTextFormat( ref.label.getTextFormat() );
-			label.width = ref.label.width;
-			label.height = ref.label.height;
-			label.wordWrap = true;
-			label.x = ref.label.x;
-			label.y = ref.label.y;
-			label.visible = true;
-			panel.addChild( label );
-			
-			// Button - either an intert check or an ingredient info button
-			var button:GraphicButton; 
-			if ( ingredient.spotlight != "" )
-			{
-				var img:Bitmap = ResMan.instance.getImage( "2d/Buttons/btn_info_up" );
-				var imgOver:Bitmap = ResMan.instance.getImage( "2d/Buttons/btn_info_over" );
-				button = new GraphicButton( img, img, imgOver, img, null, onButtonHit );
-			}
-			else
-			{
-				var img:Bitmap = ResMan.instance.getImage( "2d/Buttons/btn_checkSmall_up" );
-				var imgOver:Bitmap = ResMan.instance.getImage( "2d/Buttons/btn_checkSmall_over");
-				button = new GraphicButton( img, img, imgOver, img, null ); // check has no special hit behavior
-				button.enabled = false; // Check "buttons" are not interactable.
-			}
-			
-			button.x = ref.button.x;
-			button.y = ref.button.y;
-			button.width = ref.button.width;
-			button.height = ref.button.height;
-			button.name = "ingredient_" + ingredient.name;
-			button.visible = true;
-			panel.addChild( button );
-			
-			// Add item to menu
-			m_IngredientsMenu.addItem( panel, button ); 
-			
-			// Increment offset 
-			offset += button.height * 1.25 ; // Additional spacing so they don't overlap in overstate
+			StateManager.setState( GameState.INGREDIENTINFO,  { args: [ GameState.RECIPEINGREDIENTS, selectedIngredient] } );
 		}
 	}
 	
-	private function createTools():Void
+	private function onToolHit( ?caller:GraphicButton ):Void
 	{
-		// Get paist item for display ref: Tools 
-		var tPanel:DisplayObjectContainer = cast this.getChildByName( "group_tool1" );
-		var tLabel:TextField = cast tPanel.getChildByName( "lbl_tool1" );
-		var tButton:GraphicButton = cast tPanel.getChildByName( "btn_tool1" );
+		WebAudio.instance.play( "SFX/button_click" );	
 		
-		var ref:ToolGroup = cast { panel: tPanel, label: tLabel, button: tButton, tool: null };
-		
-		var yOffset:Float = 0;
-		var xOffset:Float = 0; // places items in two columns 
-		
-		// Loop through this recipe's tools
-		for ( tool in FlowController.data.selectedRecipe.tools )
+		for ( tool in FlowController.data.selectedRecipe.tools)
 		{
-			// Holding panel
-			var panel:DisplayObjectContainer = new DisplayObjectContainer();
-			panel.x = ref.panel.x + xOffset; 
-			panel.y = ref.panel.y + yOffset;
-			panel.name = tool.name;
-			this.addChild( panel );
-			
-			// Button
-			var img:Bitmap;
-			var imgDown:Bitmap;
-			var imgOver:Bitmap;
-			var imgDisabled:Bitmap;
-			if ((tool.URL == null) || (tool.URL == ""))
+			if ( tool.name == name )
 			{
-				img = ResMan.instance.getImage( "2d/Buttons/btn_store_disabled", false );
-				imgDown = null;
-				imgOver  = null;
-				imgDisabled = null;
+				goToUrl( tool.URL );
+				return;
 			}
-			else
-			{
-				img = ResMan.instance.getImage( "2d/Buttons/btn_store_up", false );
-				imgDown = ResMan.instance.getImage( "2d/Buttons/btn_store_down" );
-				imgOver = ResMan.instance.getImage( "2d/Buttons/btn_store_over", false );
-				imgDisabled = null;
-			}
-			
-			var button:GraphicButton = new GraphicButton( img, imgDown, imgOver, imgDisabled, null, onButtonHit );
-			button.enabled = (tool.URL != null) && (tool.URL != "");
-			
-			button.x = ref.button.x;
-			button.y = ref.button.y;
-			button.name = "tool_" + tool.name;
-			panel.addChild( button );
-			
-			// Label to display the tool name 
-			var label:TextField = new TextField();
-			label.text = tool.name; 
-			label.setTextFormat( ref.label.getTextFormat() );
-			label.autoSize = TextFieldAutoSize.LEFT;
-			label.x = ref.label.x;
-			label.y = ref.label.y;
-			panel.addChild( label );
-			
-			// Add item to menu
-			m_ToolsMenu.addItem( panel, button ); 
-			
-			// Place tools in two columns
-			// Flip the x position, increment y every other placement 
-			if ( xOffset > 0 )
-			{
-				xOffset = 0;
-				yOffset += button.height;
-			}
-			else
-			{
-				xOffset = TOOL_WIDTH / 2;
-			}
 		}
 	}
 	
@@ -463,10 +383,11 @@
 		StateManager.setState( GameState.PARENTAL, { args: [ GameState.RECIPEINGREDIENTS, URL] } );
 	}
 	
-	private function showMasks():Void
+	// ===================================
+	// Exit handling
+	// ===================================
+	public function dispose() 
 	{
-		// Reparent mask above newly added scroll items
-		m_ToolsMenu.reparent();
-		m_IngredientsMenu.reparent();
+		 // todo
 	}
 }
\ No newline at end of file
Index: src/game/ui/VirtualScrollingItem.hx
===================================================================
--- src/game/ui/VirtualScrollingItem.hx	(revision 829)
+++ src/game/ui/VirtualScrollingItem.hx	(working copy)
@@ -16,6 +16,7 @@
 import com.firstplayable.hxlib.display.GraphicButton;
 import com.firstplayable.hxlib.display.OPSprite;
 import com.firstplayable.hxlib.loader.ResMan;
+import format.swf.Data.FontLayoutData;
 import openfl.display.Bitmap;
 import openfl.display.DisplayObject;
 import openfl.display.DisplayObjectContainer;
@@ -36,7 +37,7 @@
 {
 	private var refGroup:DisplayObjectContainer;
 	private var group:DisplayObjectContainer;
-	public var  debugName:Int;
+	public var  debugName:String;
 	
 	// Display objects (update these for individual-list functionality. 
 	//		See also: ScrollingData class in VirtualScrollingItem.hx
@@ -59,7 +60,6 @@
 		// ---------------------------------------------------
 		m_buttons = new Array();
 		refGroup = displayGroup;
-		debugName = count;
 		
 		// ---------------------------------------------------
 		// Create new display object group from ref
@@ -164,6 +164,7 @@
 		var refHeight = m_label.height;
 		
 		m_label.text = text;
+		debugName = text;
 		
 		if ( m_label.autoSize == TextFieldAutoSize.NONE )
 		{
@@ -218,6 +219,12 @@
 		}
 	}
 	
+	public function setCoordinates( posX:Float, posY:Float )
+	{
+		group.x = posX;
+		group.y = posY;		
+	}
+	
 	/**
 	 *  Loop through to find if param x/y pos is contained within any button sprites.
 	 *  Call button's onHit if so, and return true.
@@ -292,8 +299,22 @@
 		}
 	}
 	
+	public function posX():Float
+	{
+		return group.x;
+	}
+	
+	public function posY():Float
+	{
+		return group.y; 
+	}
+	
 	public function clear():Void
 	{
+		m_buttons = [];
+		m_image = null;
+		m_label = null;
+		
 		group.parent.removeChild( group );
 	}
 	
@@ -384,7 +405,7 @@
 	   newDOC.y = ref.y;
 	   
 	   ref.parent.addChild( newDOC );
-	   
+	 
 	   return newDOC;
 	}
 }
\ No newline at end of file
Index: src/game/ui/VirtualScrollingMenu.hx
===================================================================
--- src/game/ui/VirtualScrollingMenu.hx	(revision 829)
+++ src/game/ui/VirtualScrollingMenu.hx	(working copy)
@@ -69,6 +69,8 @@
  *  A menu that handles the movement and data population of single-row/column scrolling lists. 
  *  See MultidimensionalScrollingMenu for multi row/column support.
  * 
+ * (Design TODO - make this a root class and split single and multidimensional logic both into extensions) 
+ * 
  *  To be added as a child of an existing menu, and used to handle user input and the respositioning of items. 
  *  Items are still children of the parent menu.
  * 
@@ -116,6 +118,8 @@
 	private var m_scrollTrack:OPSprite;
 	
 	
+	
+	
 	/**
 	 * Setup requires: 
 	 * 		- two example groups of display objects for reference
@@ -171,6 +175,16 @@
 		m_scrollArea.graphics.endFill();
 		
 		// ---------------------------------------------------
+		// Early return if invalid ref.
+		// (Also a signal for multidimensional scroll override.)
+		// ---------------------------------------------------
+		if ( refGroup1 == null || refGroup2 == null )
+		{
+			Debug.log( "Null ref; ScrollingMenu returning early from constructor" );
+			return;
+		}
+		
+		// ---------------------------------------------------
 		// Init other member vars using paist ref:
 		// - Visisble items
 		// - Item spacing
@@ -311,7 +325,8 @@
 			return;
 		}
 		
-		for ( i in 0...m_scrollingItems.length) // Populate items idx 1->length with data starting at idx 0. Item 0 is above field of view.
+		var numItems:Int = Math.floor( Math.min(m_scrollingItems.length, m_dataset.length) );
+		for ( i in 0...numItems ) // Populate items idx 1->length with data starting at idx 0. Item 0 is above field of view.
 		{
 			m_scrollingItems[i].updateData( m_dataset[i] );
 		}
@@ -326,6 +341,7 @@
 	 */
 	public function addData( imgSrc:String, pBtnSrc:Bitmap, sBtnSrc:Bitmap, lbl:String )
 	{
+		trace( "adding " + lbl );
 		var data:ScrollingData = new ScrollingData( imgSrc, pBtnSrc, sBtnSrc, lbl );
 		m_dataset.push( data );
 	}
@@ -420,7 +436,8 @@
 	private function scrolledOneItemBackward():Bool
 	{
 		var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
-		return ( lastItem.pos( m_orientation ) + m_itemSize <= m_lowerScrollLimit );
+		var lastItemBottom:Float = lastItem.pos( m_orientation ) + m_itemSize;
+		return ( lastItemBottom <= m_lowerScrollLimit );
 	}
 	
 	/**
@@ -458,7 +475,7 @@
 	/**
 	 * Derive movement direction based on the sign of the distance float 
 	 */
-	private function getDirection( distance:Float )
+	private function getDirection( distance:Float ):Direction
 	{
 		var dir:Direction;
 		if ( distance > 0 )
@@ -469,7 +486,6 @@
 		{
 			dir = BACKWARD;
 		}
-		
 		return dir;
 	}
 	
@@ -556,9 +572,10 @@
 		}
 		
 		var distance:Float = pos - m_overPos;
-		if ( distance > MAX_FRAME_DISTANCE )
+		if ( Math.abs( distance ) > MAX_FRAME_DISTANCE )
 		{
-			distance = MAX_FRAME_DISTANCE;
+			if ( distance > 0 ) distance = MAX_FRAME_DISTANCE;
+			else if ( distance < 0 ) distance = MAX_FRAME_DISTANCE * -1;
 		}
 		
 		m_overPos = pos;
@@ -565,7 +582,6 @@
 		
 		m_direction = getDirection( distance );
 		
-		
 		// ----------------------------------------------------------
 		// Early return if we are scrolling towards respective limits
 		// ----------------------------------------------------------
@@ -759,7 +775,6 @@
 		m_scrollBar.y += scrollBarDistance;
 	}
 	
-	
 	// ===================================
 	// Cleanup/Exit handling
 	// ===================================
