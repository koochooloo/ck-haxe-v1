Index: Engineering/src/game/ui/states/RecipeStepsMenu.hx
===================================================================
--- Engineering/src/game/ui/states/RecipeStepsMenu.hx	(revision 879)
+++ Engineering/src/game/ui/states/RecipeStepsMenu.hx	(working copy)
@@ -24,9 +24,10 @@
 import game.Step.StepTypes;
 import game.controllers.FlowController;
 import game.def.GameState;
-import game.ui.ScrollingManager;
+import game.ui.VirtualScrollingMenu;
 import game.ui.SpeckMenu;
 import game.ui.states.RecipeStepsMenu.StepGroup;
+import openfl.display.Bitmap;
 import openfl.display.DisplayObject;
 import openfl.display.DisplayObjectContainer;
 import openfl.text.TextField;
@@ -53,11 +54,8 @@
 {
 	// ------ Static tunable vars:
 	// TODO - callback to pull from paist bounding box
-	private static inline var SCROLLWIDTH:Float = 1000;
-	private static inline var SCROLLHEIGHT:Float = 600;
-	private static inline var DISPLAYNUM:Int = 2;
 	
-	private var m_scrollMenu:ScrollingManager;
+	private var m_scrollMenu:VirtualScrollingMenu;
 
 	public function new(p:GameStateParams) 
 	{
@@ -68,168 +66,32 @@
 		title.text = FlowController.data.selectedRecipe.name; 
 		
 		// Create scrolling menu
-		var scrollBounds:DisplayObjectContainer = cast getChildByName( "scroll_bounds" );
-		m_scrollMenu = new ScrollingManager( scrollBounds.x, scrollBounds.y, SCROLLWIDTH, SCROLLHEIGHT, this, "vertical", DISPLAYNUM );
+		var ref1:DisplayObjectContainer = cast getChildByName( "group_step_1");
+		var ref2:DisplayObjectContainer = cast getChildByName( "group_step_2");
+		var scrollBounds:OPSprite = cast getChildByName( "spr_scrollBounds" );
+		m_scrollMenu = new VirtualScrollingMenu( scrollBounds, Orientation.VERTICAL, ref1, ref2 );
 		
 		// Create steps and add them to the scrolling menu
-		initSteps();
+		addScrollingData();
 
 		// Initialize the scrolling menu
+		this.addChild( m_scrollMenu );
 		m_scrollMenu.init();
-		this.addChild( m_scrollMenu );
 	}
 	
-	/**
-	 *  Populate a scrolling list of steps using paist menu assets
-	 */
-	private function initSteps():Void
-	{
-		// Get sample step assets from the paist menu - three possible sizes [ small, med, large ]
-		var paistGroups:Array< StepGroup > = getPaistGroups();
-		
+	private function addScrollingData():Void
+	{	
 		// Create steps from recipe steps and paist reference. Pass them to the scroll manager.
-		var ref:StepGroup;
-		var offset:Float = 0;
-		var increment:Float = 0;
 		for ( step in FlowController.data.selectedRecipe.steps )
 		{
-			// Determine ref panel size (small/medium/large) based on step char count
-			var len:Float = step.instruction.length;
-			var small:Float = paistGroups[0].menuPane.height;
-			var med:Float = paistGroups[1].menuPane.height;
-			var large:Float = paistGroups[2].menuPane.height;
-			var size:String;
+			trace( "added: " + step.instruction );
 			
-			if ( len <= small )
+			var imgSrc:Bitmap = switch ( step.type )
 			{
-				size = "small";
-				ref = paistGroups[0];
-				increment = small;
+				case game.StepTypes.BIGCHEF: ResMan.instance.getImage( "2d/UI/chefBig" );
+				case game.StepTypes.LITTLECHEF: ResMan.instance.getImage( "2d/UI/chefLittle" );
 			}
-			else if ( len > small && len <= med )
-			{
-				size = "medium";
-				ref = paistGroups[1];
-				increment = med;
-			}
-			else 
-			{
-				size = "large";
-				ref = paistGroups[2];
-				increment = large;
-			}
-			
-			// Panel for object parenting/relative positioning
-			var panel:DisplayObjectContainer = new DisplayObjectContainer();
-			panel.x = ref.panel.x;
-			panel.y = ref.panel.y + offset;
-			this.addChild( panel );
-			
-			// Display panel for step text 
-			var menu:OPSprite = new OPSprite( ResMan.instance.getImage( "2d/UI/panel_" + size ) );
-			menu.x = ref.menuPane.x;
-			menu.y = ref.menuPane.y;
-			panel.addChild( menu );
-			
-			// Green bubble icon behind the step number 
-			var icon:OPSprite = new OPSprite( ResMan.instance.getImage( "2d/UI/stepNumber" ) );
-			icon.x = ref.stepIcon.x;
-			icon.y = ref.stepIcon.y;
-			panel.addChild( icon );
-			
-			// Label with step instructions
-			var label:TextField = new TextField();
-			label.text = step.instruction;
-			label.x = ref.label.x;
-			label.y = ref.label.y;
-			label.setTextFormat( ref.label.getTextFormat() );
-			label.height = ref.label.height;
-			label.width = ref.label.width;
-			label.multiline = true;
-			label.wordWrap = true;
-			panel.addChild( label );
-			
-			// Label with step number
-			var number:TextField = new TextField();
-			number.text = Std.string( step.order + 1 ); // Step order is zero-indexed
-			number.autoSize = TextFieldAutoSize.CENTER;
-			number.setTextFormat( ref.stepNumber.getTextFormat() );
-			number.x = ref.stepNumber.x;
-			number.y = ref.stepNumber.y;
-			panel.addChild( number );
-			
-			// Big/little chef icon, depending on step type
-			var chef:OPSprite; 
-			switch ( step.type )
-			{
-				case StepTypes.BIGCHEF: 		
-				{
-					chef = new OPSprite( ResMan.instance.getImage( "2d/UI/chefBig" ) );
-					chef.x = ref.chef.x;
-					chef.y = ref.chef.y;
-				}
-				case StepTypes.LITTLECHEF: 
-				{
-					chef = new OPSprite( ResMan.instance.getImage( "2d/UI/chefLittle" ) );
-					chef.x = ref.chef.x;
-					chef.y = ref.chef.y;
-				}
-			}
-			panel.addChild( chef );
-			
-			// Dummy button, menu size
-			var button:GraphicButton = new GraphicButton( menu.getBitmap() );
-			button.name = Std.string( step.order );
-			
-			// Add item to scroll menu
-			m_scrollMenu.addItem( panel, button );
-			
-			// Increment offset
-			offset += increment;
+			m_scrollMenu.addData( imgSrc, null, null, step.instruction, Std.string( step.order + 1 ) ); // Step order is zero-indexed
 		}
-		
-		showMasks();
 	}
-	
-	private function getPaistGroups():Array< StepGroup >
-	{
-		var paistGroups:Array< StepGroup > = new Array();
-		for (i in 0...3)
-		{
-			var size:String = null;
-			switch(i)
-			{
-				case 0: size = "small";
-				case 1: size = "medium";
-				case 2: size = "large";
-			}
-			
-			var panel:DisplayObjectContainer = cast getChildByName("group_step_" + size);
-			var pane:OPSprite = cast panel.getChildByName("panelStep_" + size);
-			var stepIcon:OPSprite = cast panel.getChildByName("stepIcon_" + size);
-			var big:OPSprite = cast panel.getChildByName("chefBig_" + size);
-			var label:TextField = cast panel.getChildByName("lbl_step_" + size);
-			var stepNumber:TextField = cast panel.getChildByName("lbl_stepNumber_" + size);
-			panel.visible = false;
-			
-			var group:StepGroup = { 
-				panel: panel, 
-				menuPane: pane, 
-				stepIcon: stepIcon, 
-				chef: big, 
-				label: label, 
-				stepNumber: stepNumber
-			};
-			paistGroups.push(group);
-		}
-		
-		return paistGroups;
-	}
-	
-	private function showMasks():Void
-	{
-		// Reparent menu sprites on top of newly added sprites
-		m_scrollMenu.reparent();
-		
-	}
 }
\ No newline at end of file
Index: Engineering/src/game/ui/VirtualScrollingItem.hx
===================================================================
--- Engineering/src/game/ui/VirtualScrollingItem.hx	(revision 879)
+++ Engineering/src/game/ui/VirtualScrollingItem.hx	(working copy)
@@ -35,7 +35,7 @@
 class VirtualScrollingItem extends DisplayObjectContainer
 {
 	private var refGroup:DisplayObjectContainer;
-	private var group:DisplayObjectContainer;
+	public var group:DisplayObjectContainer;
 	public var  debugName:Int;
 	
 	// Display objects (update these for individual-list functionality. 
@@ -43,6 +43,7 @@
 	private var m_image:OPSprite;
 	private var m_buttons:Array< GraphicButton >; // List should be in display order, since it is populated from __children; reverse to hit front layered buttons first?
 	private var m_label:TextField;
+	private var m_secondaryLabel:TextField;
 
 	
 	// Button overstate scaling
@@ -86,11 +87,18 @@
 			}
 			else if ( Std.is( child, TextField ) )
 			{
-				createTextFromRef( cast (child, TextField), count );
+				if ( m_label == null )
+				{
+					m_label = createTextFromRef( cast (child, TextField), count );
+				}
+				else
+				{
+					m_secondaryLabel = createTextFromRef( cast (child, TextField), count );
+				}
 			}
 			else if ( Std.is( child, OPSprite ) )
 			{
-				createSpriteFromRef( cast (child, OPSprite) );
+				m_image = createSpriteFromRef( cast (child, OPSprite) );
 			}
 		}
 	}
@@ -122,14 +130,19 @@
 	{
 		switch ( data.imgSrc )
 		{
-			case Some( src ): setImage( src );
+			case Some( bitmap ): setImage( bitmap );
 			case None: //
 		}
 		switch ( data.label )
 		{
-			case Some( text ): setText( text );
+			case Some( text ): setText( text, m_label );
 			case None: //
 		}
+		switch ( data.secondaryLabel )
+		{
+			case Some( label ): setText( label, m_secondaryLabel );
+			case None: //
+		}
 		switch ( data.primaryButtonSrc )
 		{
 			case Some( bitmap ): setButton( bitmap, m_buttons[0] );
@@ -140,6 +153,10 @@
 			case Some( bitmap ): setButton( bitmap, m_buttons[1] );
 			case None: //
 		}
+		
+		
+		m_baseScaleX = group.scaleX;
+		m_baseScaleY = group.scaleY;
 	}
 	
 	/**
@@ -147,10 +164,10 @@
 	 * Assumes one image in display list
 	 * Naiive - TODO database integration
 	 */
-	private function setImage( src:String ):Void
+	private function setImage( bitmap:Bitmap ):Void
 	{
-		var bitmap:Bitmap = ResMan.instance.getImage( src );
 		m_image.changeImage( bitmap );
+		m_image.visible = true;
 	}
 	
 	/**
@@ -158,17 +175,22 @@
 	 * Assumes one image in display list
 	 * Naiive - TODO database integration
 	 */
-	private function setText( text:String ):Void
+	private function setText( text:String, label:TextField ):Void
 	{
-		var refWidth = m_label.width;
-		var refHeight = m_label.height;
+		trace( "======================== setting label text: " );
+		trace( "\t initial text: " + label.text );
+		trace( "\t alt. text: " + text );
+		trace( "=============================================" );
 		
-		m_label.text = text;
+		var refWidth = label.width;
+		var refHeight = label.height;
 		
-		if ( m_label.autoSize == TextFieldAutoSize.NONE )
+		label.text = text;
+		
+		if ( label.autoSize == TextFieldAutoSize.NONE )
 		{
-			m_label.width = refWidth;
-			m_label.height = refHeight;
+			label.width = refWidth;
+			label.height = refHeight;
 		}
 	}
 	
@@ -267,21 +289,21 @@
 	 */
 	public function handleButtonOverState( posX:Float, posY:Float ):Void
 	{
+		
 		for ( button in m_buttons )
 		{
-			var scaledUp:Bool = ( button.scaleX > m_baseScaleX && button.scaleY > m_baseScaleY );
-			var scaledDown:Bool = ( button.scaleX <= m_baseScaleX && button.scaleY <= m_baseScaleY );
+			var scaledUp:Bool = ( group.scaleX > m_baseScaleX && group.scaleY > m_baseScaleY );
+			var scaledDown:Bool = ( group.scaleX <= m_baseScaleX && group.scaleY <= m_baseScaleY );
 			
-			// If scaled up and mouse isn't over the button, scale down again
 			if ( !pointInObject( posX, posY, button ) && scaledUp ) 
 			{
-				button.scaleX /= BUTTON_OVERSTATE_SCALE;
-				button.scaleY /= BUTTON_OVERSTATE_SCALE;	
+				group.scaleX /= BUTTON_OVERSTATE_SCALE;
+				group.scaleY /= BUTTON_OVERSTATE_SCALE;	
 			}
 			else if ( pointInObject( posX, posY, button ) && scaledDown )
 			{
-				button.scaleX *= BUTTON_OVERSTATE_SCALE;
-				button.scaleY *= BUTTON_OVERSTATE_SCALE;
+				group.scaleX *= BUTTON_OVERSTATE_SCALE;
+				group.scaleY *= BUTTON_OVERSTATE_SCALE;
 			}
 		}
 	}
@@ -339,11 +361,7 @@
 		newBtn.cursor = ref.cursor;
 		newBtn.rotation = ref.rotation;
 		newBtn.name = ref.name;
-		
-		m_baseScaleX = ref.scaleX;
-		m_baseScaleY = ref.scaleY;
 
-
 		m_buttons.push( newBtn );
 		group.addChild( newBtn );
 	
@@ -372,7 +390,7 @@
 		m_label = newTxt;
 		group.addChild( newTxt );
 		
-		return m_label;
+		return newTxt;
 	}
 	
 	/**
@@ -380,7 +398,9 @@
 	 */
 	private function createSpriteFromRef( ref:OPSprite ):OPSprite
 	{
-		var newSprite:OPSprite = new OPSprite( ref.getBitmap(), ref.getBoundsData() );
+		var newSprite:OPSprite = new OPSprite();
+		newSprite.bitmapData = ref.getBitmapData();
+
 		newSprite.width = ref.width;
 		newSprite.height = ref.height;
 		newSprite.x = ref.x;
@@ -388,12 +408,11 @@
 		newSprite.visible = ref.visible;
 		newSprite.alpha = ref.alpha;
 		newSprite.rotation = ref.rotation;
-		newSprite.name = ref.name; 
+		newSprite.name = ref.name + debugName;
+		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
+		group.addChildAt( newSprite, group.numChildren );
 		
-		m_image = newSprite;
-		group.addChild( newSprite );
-		
-		return m_image;
+		return newSprite;
 	}
 	
 	private function createDOCFromRef( ref:DisplayObjectContainer ):DisplayObjectContainer
@@ -407,4 +426,32 @@
 	 
 	   return newDOC;
 	}
+	
+	public function print():Void
+	{
+		trace( "Group: " + debugName );
+		trace( "Position: (" + group.x + ", " + group.y + ")" );
+		trace( "Dimensions: " + group.width + " " + group.height );
+		trace( "visible: " + group.visible );
+		trace( "alpha: " + group.alpha );
+		trace( "group parent: " + group.parent );
+		trace( "mask: " + group.mask );
+		for ( child in group.__children )
+		{
+			trace( "\t" + child );
+			trace( "\t\t Position: (" + child.x + ", " + child.y + ")" );
+			trace( "\t\t Dimensions: " + child.width + " " + child.height );
+			trace( "\t\t visible: " + child.visible );
+			trace( "\t\t alpha: " + child.alpha );
+			
+			if ( Std.is( child, OPSprite ) && !Std.is( child, GraphicButton ) )
+			{
+				var img:OPSprite = cast child;
+				trace( "\t\t bitmap:" + img.bitmapData );
+				trace( "\t\t bitmap:" + img.getBitmap().name );
+				trace( "\t\t sprite mask: " + img.mask );
+				
+			}
+		}
+	}
 }
\ No newline at end of file
Index: Engineering/src/game/ui/VirtualScrollingMenu.hx
===================================================================
--- Engineering/src/game/ui/VirtualScrollingMenu.hx	(revision 879)
+++ Engineering/src/game/ui/VirtualScrollingMenu.hx	(working copy)
@@ -12,6 +12,7 @@
 ///////////////////////////////////////////////////////////////////////////
 
 package game.ui;
+import away3d.textfield.TextField;
 import com.firstplayable.hxlib.Debug;
 import com.firstplayable.hxlib.display.OPSprite;
 import game.ui.VirtualScrollingMenu.ScrollingData;
@@ -32,17 +33,20 @@
  */
 class ScrollingData
 {
-	public var imgSrc(default, null):Option< String >; // bitmap src URL
+	public var imgSrc(default, null):Option< Bitmap >; // bitmap src URL
 	public var primaryButtonSrc(default, null):Option< Bitmap >;
-	public var secondaryButtonSrc(default, null):Option< Bitmap >; 
+	public var secondaryButtonSrc(default, null):Option< Bitmap >;
 	public var label(default, null):Option< String >;  // text used to populate scrolling item label
+	public var secondaryLabel(default, null):Option< String >;
 	
-	public function new( ?img:String, ?pBtn:Bitmap, ?sBtn:Bitmap, ?lbl:String )
+	public function new( ?img:Bitmap, ?pBtn:Bitmap,?sBtn:Bitmap, ?lbl:String, ?lbl2:String )
 	{
 		imgSrc = (img != null) ? Some(img):None;
 		primaryButtonSrc = (pBtn != null) ? Some(pBtn):None;
+		label = (lbl != null) ? Some(lbl):None;
+		secondaryLabel = (lbl2 != null) ? Some(lbl2):None;
 		secondaryButtonSrc = (sBtn != null) ? Some(sBtn):None;
-		label = (lbl != null) ? Some(lbl):None;
+
 	}
 }
 
@@ -96,6 +100,7 @@
 	private var m_orientation:Orientation; // Horizontal or vertical
 	private var m_itemSpacing:Float; // Pixels - Vertical/horizontal space between item placement, depending on orientation. Includes item size + padding.
 	private var m_itemSize:Float; // Pixels - Horizontal = width, vertical = height. List assumes uniform items.
+	private var m_paistRef:DisplayObjectContainer; // Keep main ref for redrawing items
 	
 	// Movement helpers
 	private var m_isMouseDown:Bool;
@@ -117,9 +122,6 @@
 	private var m_scrollBar:OPSprite;
 	private var m_scrollTrack:OPSprite;
 	
-	
-	
-	
 	/**
 	 * Setup requires: 
 	 * 		- two example groups of display objects for reference
@@ -192,6 +194,7 @@
 		// - Start & End pos
 		// - List of scrolling items
 		// ---------------------------------------------------
+		m_paistRef = refGroup1;
 		addRef( refGroup1, refGroup2 );
 		
 		// ---------------------------------------------------
@@ -241,9 +244,21 @@
 			case VERTICAL:   refGroup1.y = m_startPos;
 		}
 		
+		populateScrollingItems();
+		
+		// Hide ref when we're done using it
+		refGroup1.visible = false; 
+		refGroup2.visible = false;
+	}
+	
+	private function populateScrollingItems()
+	{
 		// Populate scrollingItems using the visible item number. 
 		// Number of virtually scrolling display objects should be 1 + visibleItems 
 		//		( All that are visible and one just below view; list display starts off at the top)
+		var startX:Float = m_paistRef.x;
+		var startY:Float = m_paistRef.y;
+		
 		var numItems:Int = m_visibleItems + 1;
 		var count:Int = 0;
 		
@@ -254,13 +269,13 @@
 			{
 				switch( m_orientation )
 				{
-					case HORIZONTAL: refGroup1.x += m_itemSpacing;
-					case VERTICAL:   refGroup1.y += m_itemSpacing;
+					case HORIZONTAL: m_paistRef.x += m_itemSpacing;
+					case VERTICAL:   m_paistRef.y += m_itemSpacing;
 				}
 			}
 
 			// Create & add scrolling item
-			var item = new VirtualScrollingItem( refGroup1, count );
+			var item = new VirtualScrollingItem( m_paistRef, count );
 			m_scrollingItems.push( item );
 			
 			// Add mask to scrolling item
@@ -272,9 +287,8 @@
 			count++;
 		}
 		
-		// Hide ref when we're done using it
-		refGroup1.visible = false; 
-		refGroup2.visible = false;
+		m_paistRef.x = startX;
+		m_paistRef.y = startY;
 	}
 	
 	/**
@@ -289,7 +303,8 @@
 		start();
 		
 		// Hide scroll bar if it is not needed
-		if ( m_visibleItems >= m_dataset.length )
+		var haveScrollUI:Bool = m_scrollBar != null && m_scrollTrack != null;
+		if ( haveScrollUI && (m_visibleItems >= m_dataset.length) )
 		{
 			m_scrollBar.visible = false;
 			m_scrollTrack.visible = false;
@@ -339,9 +354,9 @@
 	/**
 	 * Adds data to virtual scrolling menu, to be populated onto objects
 	 */
-	public function addData( imgSrc:String, pBtnSrc:Bitmap, sBtnSrc:Bitmap, lbl:String )
+	public function addData( ?imgSrc:Bitmap, ?pBtnSrc:Bitmap, ?sBtnSrc:Bitmap, ?lbl:String, ?lbl2:String )
 	{
-		var data:ScrollingData = new ScrollingData( imgSrc, pBtnSrc, sBtnSrc, lbl );
+		var data:ScrollingData = new ScrollingData( imgSrc, pBtnSrc, sBtnSrc, lbl, lbl2 );
 		m_dataset.push( data );
 	}
 
@@ -350,7 +365,14 @@
 	 */
 	private function atUpperScrollLimit():Bool
 	{
-		return ( (scrolledOneItemForward() && m_userPos <= 0) );
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot detect upper scroll limits; no data available." );
+			return true;
+		}
+		
+		return ( scrolledOneItemForward() && m_userPos <= 0);
 	}
 	
 	/**
@@ -358,6 +380,13 @@
 	 */
 	private function atLowerScrollLimit():Bool
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot detect lower scroll limits; no data available." );
+			return true;
+		}
+		
 		var lastDataPos:Int = m_dataset.length - 1;
 		return  scrolledOneItemBackward() && ( m_userPos >= (lastDataPos - m_visibleItems ) );
 	}
@@ -424,6 +453,13 @@
 	 */
 	private function scrolledOneItemForward():Bool
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot scroll forward. No items in scrolling list." );
+			return false;
+		}
+		
 		var firstItem:VirtualScrollingItem = m_scrollingItems[ 0 ];
 		return ( firstItem.pos(m_orientation) >= m_upperScrollLimit);
 	}
@@ -434,6 +470,13 @@
 	 */
 	private function scrolledOneItemBackward():Bool
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot scroll backward. No items in scrolling list." );
+			return false;
+		}
+		
 		var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
 		return ( lastItem.pos( m_orientation ) + m_itemSize <= m_lowerScrollLimit );
 	}
@@ -444,6 +487,13 @@
 	 * */
 	private function repositionAtStart():VirtualScrollingItem
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot reposition items at start of list. No items in scrolling list." );
+			return null;
+		}
+		
 		var lastItem:VirtualScrollingItem = m_scrollingItems.pop();
 		var firstItem:VirtualScrollingItem = m_scrollingItems[ 0 ];
 		
@@ -460,6 +510,13 @@
 	 * */
 	private function repositionAtEnd():VirtualScrollingItem
 	{
+		// Early return for empty items 
+		if ( m_scrollingItems.length < 1 )
+		{
+			Debug.log( "Cannot reposition items at end of list. No items in scrolling list." );
+			return null;
+		}
+		
 		var firstItem:VirtualScrollingItem = m_scrollingItems.shift();
 		var lastItem:VirtualScrollingItem = m_scrollingItems[ m_scrollingItems.length - 1 ];
 		
@@ -579,7 +636,6 @@
 		m_overPos = pos;
 		
 		m_direction = getDirection( distance );
-		
 		// ----------------------------------------------------------
 		// Early return if we are scrolling towards respective limits
 		// ----------------------------------------------------------
@@ -784,6 +840,17 @@
 	
 	private function dispose():Void
 	{
+		removeScrollListeners();
+		
+		// Clear menu
+		clearData();
+		
+		// Remove event listeners from menu
+		this.removeEventListener( Event.REMOVED_FROM_STAGE, onRemoved );
+	}
+	
+	private function removeScrollListeners():Void
+	{
 		// Remove listeners from the scroll interaction sprite
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_UP, onMouseUp ); 
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_DOWN, onMouseDown ); 
@@ -790,15 +857,52 @@
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_MOVE, onMouseMove );
 		m_scrollArea.removeEventListener( MouseEvent.MOUSE_OUT, onMouseOut);
 		m_scrollArea.removeEventListener( Event.ENTER_FRAME, onFrame );
+	}
+	
+	/**
+	 * Clears scroll data for reinitialization. 
+	 */
+	public function reset():Void
+	{
+		m_paistRef.visible = true;
 		
-		// Remove listeners from items
-		// Clear items
+		clearData();
+	}
+	
+	/**
+	 * To be called after clearing data; at the moment used for search functionality
+	 */
+	public function reInit()
+	{
+		populateScrollingItems();
+		init();
+		
+		// Clear list if there is no data
+		if ( m_dataset.length < 1 )
+		{
+			clearData();
+			Debug.log( "No data availabile on reinitialization." );
+		}
+		
+		m_paistRef.visible = false;
+	}
+	
+	/**
+	 * Clears scroll data and display objects from the menu. Also removes event listeners.
+	 */
+	private function clearData():Void
+	{
+		m_isTweening = false;
+		removeScrollListeners();
+		
+		m_userPos = 0;
+		m_dataset = [];
+		
 		for ( item in m_scrollingItems )
 		{
 			item.clear();
 		}
 		
-		// Remove event listeners from menu
-		this.removeEventListener( Event.REMOVED_FROM_STAGE, onRemoved );
+		m_scrollingItems = [];
 	}
 }
\ No newline at end of file
