##
## Copyright (C) 2015, 1st Playable Productions, LLC. All rights reserved.
##
## UNPUBLISHED -- Rights reserved under the copyright laws of the United
## States. Use of a copyright notice is precautionary only and does not
## imply publication or disclosure.
##
## THIS DOCUMENTATION CONTAINS CONFIDENTIAL AND PROPRIETARY INFORMATION
## OF 1ST PLAYABLE PRODUCTIONS, LLC. ANY DUPLICATION, MODIFICATION,
## DISTRIBUTION, OR DISCLOSURE IS STRICTLY PROHIBITED WITHOUT THE PRIOR
## EXPRESS WRITTEN PERMISSION OF 1ST PLAYABLE PRODUCTIONS, LLC.
###########################################################################
import os
import re
import argparse
import sys
import json

MIN_ARGS = 2

class JsonToHaxe( object ):
	def __init__( self, outputFilePath ):
		self.outputFile = open( outputFilePath, 'w' )

	def writeClassBegin( self ):
		self.outputFile.write( "package assets;\n" )
		self.outputFile.write( "\n//WARNING! THIS CLASS IS AUTO-GENERATED BY TOOLS. YOUR CHANGES WILL BE OVERWRITTEN." )
		self.outputFile.write( "\nclass JsonAssets\n{" )

	def findFiles( self, sourceDirectory ):
		sourceDirectory = os.path.abspath( sourceDirectory )
		#Walk through the source directory
		for root, dirs, files in os.walk( sourceDirectory ):
			dirs.sort() # traverse subdirs in sorted order
			for curFile in sorted(files):
				name, ext = os.path.splitext( curFile )
				varname = '_' + os.path.basename( sourceDirectory ) + root.replace( sourceDirectory, '' ) + '_' + name
				#print ( "varname: " + varname )
				varname = varname.replace( '/', '_' )
				varname = varname.replace( '\\', '_' )
				varname = varname.replace( '-', '' )
				#print ( "varname: " + varname )
				if ext.lower() == ".json":
					self.writeHaxeString( root + '/' + name, varname )

	def writeClassEnd( self ):
		self.outputFile.write( '\n}' )

	def closeOutputFile( self ):
		self.outputFile.close()

	def writeHaxeString( self, file, varname ):
		url = file + ".json"
		#print( "\tWriting " + file + "..." )

		self.outputFile.write( "\n\tpublic static var " + varname + " =\n" )
		inFile = open( url, 'r' )
		output = ""

                jsonPrefix = '\t'
		jsonPostfix = '\n'

                if 'JSONASSET_TO_STRING' in os.environ:
                        jsonPrefix = '\t"'
                        jsonPostfix = '"\n'

		#json load and then dump has the effect of stripping all whitespace
		jsonData = json.load(inFile, None, None, JsonToHaxe.jsonClassHook)
		jsonText = json.dumps(jsonData, sort_keys=True, indent=None, separators=(',',':'))
		if 'JSONASSET_TO_STRING' in os.environ:
                        jsonText = re.sub(r"\"", '\\"', jsonText)

		output += jsonPrefix + jsonText + jsonPostfix


		output = output[:-1]
		self.outputFile.write( output )
		self.outputFile.write( ';\n' )
		inFile.close()

	# In order to be used directly as an typesafe anonymous structure in Haxe
	# ( http://haxe.org/manual/types-anonymous-structure.html )
	# without having to resort to parsing a string containing json data,
	# any arrays must have homogenous entry types.
	#
	# Otherwise we get an error like:
	# "Arrays of mixed types are only allowed if the type is forced to Array<Dynamic>"
	#
	# We can correct types easily for arrays of shallow objects.
	# It's harder with e.g. Paist data that contains nested dictionaries;
	# in this example, we need to recurse into "inheritable" among other things.
	# We're going for a generic recursive solution.
	#
	# This will probably fire more often than needed; we only need the "topmost" lists
	# corrected, but the extra fires won't hurt, we just get progressively more correct
	# as we head toward topmost.
	@staticmethod
	def jsonClassHook( dct ):
		for key, value in dct.iteritems():
			if isinstance( value, list ):
				keyReqs = {}
				JsonToHaxe.jsonScanList( value, keyReqs )
				JsonToHaxe.jsonFixList( value, keyReqs )
		return dct

	@staticmethod
	def jsonScanList( scanValue, seenKeys ):
		# Scan pass.
		if isinstance( scanValue, list ):
			# Flat recursion case with same seenKeys; all entries must be the same.
			for entry in scanValue:
				JsonToHaxe.jsonScanList( entry, seenKeys )
		elif isinstance( scanValue, dict ):
			#sys.stderr.write( "JsonToHaxe: saw dict: " + repr(scanValue) + "\n" )
			for key, value in scanValue.iteritems():
				#sys.stderr.write( "JsonToHaxe: saw key: " + key + "\n" )
				seenKeys.setdefault( key, {} )
				if isinstance( value, list ) or isinstance( value, dict ):
					# "Indented" recursion to build type requirements for subkey
					#sys.stderr.write( "JsonToHaxe: recurse scan on key: " + key + "\n" )
					JsonToHaxe.jsonScanList( value, seenKeys[key] )

	@staticmethod
	def jsonFixList( fixValue, seenKeys ):
		# Fixup pass.
		if isinstance( fixValue, list ):
			# Flat recursion case with same seenKeys; all entries must be the same.
			for entry in fixValue:
				JsonToHaxe.jsonFixList( entry, seenKeys )
		elif isinstance( fixValue, dict ):
			for key in seenKeys.keys():
				# This key should be present, recurse if needed; set it to None if not
				if key in fixValue:
					if isinstance( fixValue[key], list ) or  isinstance( fixValue[key], dict ):
						#sys.stderr.write( "JsonToHaxe: recurse fix on key: " + key + "\n" )
						# "Indented" recursion to build type requirements for subkey
						JsonToHaxe.jsonFixList( fixValue[key], seenKeys[key] )
				else:
					#sys.stderr.write( "JsonToHaxe: added None for key: " + key + "\n" )
					fixValue[key] = None
			if 'scale' in fixValue:
				# Tiny fixup for scale: write out as float, not int.
				# May need a more generic solution for lists of mixed int and float;
				# Could do that by having this method return mutated object, and
				# rewiring all callpoints (including within) to do sets
				# (which would in turn require tricks like 'enumerate').
				if isinstance( fixValue['scale'], list ):
					fixValue['scale'] = map( float, fixValue['scale'] )

if __name__ == "__main__":
	parser = argparse.ArgumentParser( description='Runs a module on a directory of flas and re-exports them.' )
	parser.add_argument( 'args',nargs='*' )
	options = parser.parse_args()

	numArgs = len( options.args )

	if numArgs < MIN_ARGS:
		sys.stderr.write( "Insufficient number of arguments. Expected: haxeOutputFilePath jsonDirectory [jsonDirectory]\n" )
		sys.stderr.write( "    Optionally: module to execute, args for that module\n" )
		exit

haxeOutputFilePath = os.path.abspath( options.args.pop( 0 ) ) if options.args else DEFAULT_OUTPUT_PATH
#print( "\nhaxeOutputFilePath " + haxeOutputFilePath )

reader = JsonToHaxe( haxeOutputFilePath )

reader.writeClassBegin()

#################################
# Write json files as string
##################################
while options.args:
	jsonDirectory = options.args.pop( 0 )
	reader.findFiles( jsonDirectory )

reader.writeClassEnd()
reader.closeOutputFile()
